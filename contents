 *


Entity& EntitySystem::add_new_entity  
 
	EntityID id 
    if m_free_entities size      0 
     
    	id   m_entities size   
    	m_entities push_back Entity id   
     
    else
     
    	id   m_free_entities front   
    	m_free_entities pop_front   
     

    return m_entities[id] 
 

void EntitySystem::clean_removed_entites  
 
	for auto it   m_entities_to_remove begin    it    m_entities_to_remove end      it 
	 
		movement_system   remove_id *it  
		collision_system   remove_id *it  
		damage_system   remove_id *it  
		rendering_system   remove_id *it  

		m_entities[*it] clear   
		m_free_entities push_back *it  
	 
	m_entities_to_remove clear   
 

 *


void ControlSystem::update const Time time_diff 
 
	std::for_each cbegin entities   cend entities  
	[time_diff] const EntityID id 
	 
    	if entity_system   entity id  
    	 
			Entity& entity   * entity_system   entity id   
			Control* control   entity control   
			const Health* health   entity health   


			if health alive   && health stunned      false 
				control update_decisions time_diff  
			else
				control clear_decisions   

			if control decision_attack   && control attack_proc_id   >  0 
			 
				const Position* position   entity position   
				command_queue   push std::make_unique<CallProcedureCommand> control attack_proc_id     
				if control look_dir      Control::LEFT 
				 
					command_queue   push std::make_unique<ModifyPositionCommand> position x    position y    0  0   
					command_queue   push std::make_unique<ModifyControlCommand> 0  0  0  -0 0  -0 0   
					command_queue   push std::make_unique<ModifyControlCommand> 0  0  0  -1  control look_dir     
				 
				else    Look dir is right
				 
					command_queue   push std::make_unique<ModifyPositionCommand> position x    position y    0  0   
					command_queue   push std::make_unique<ModifyControlCommand> 0  0  0  -0 0  -0 0   
					command_queue   push std::make_unique<ModifyControlCommand> 0  0  0  1  control look_dir     
				 
			 
    	 
    	else
    	 
    	 
	   
 
 *


void MovementSystem::update const Time time_delta 
 
	std::for_each cbegin entities   cend entities  
	[time_delta] const EntityID id 
	 
    	if entity_system   entity id  
    	 
			const Control* control   entity_system   entity id  control   
			Movement* movement   entity_system   entity id  movement   
			const Collision* collision   entity_system   entity id  collision   
			Position* position    entity_system   entity id  position   

			if movement gravity_affected   
			 
				movement mod_force_y GRAVITY_ACCEL*movement mass    

				if control decision_jump   && collision standing_on      Collision::GROUND 
					movement mod_velocity_y movement jump_force   movement mass    
			 
			else
			 
				if control decision_jump   
					movement mod_force_y movement move_force    
				if control decision_duck   
					movement mod_force_y -movement move_force    
			 


			movement mod_force_x movement move_force  *control decision_walk    

			const double vx_avg   movement vx     time_delta*movement fx   movement mass   2 0 
			const double vy_avg   movement vy     time_delta*movement fy   movement mass   2 0 

			movement mod_force_x -vx_avg*movement friction       account for air friction
			movement mod_force_y -vy_avg*movement friction       account for air friction

			const double sx    movement vx     time_delta*movement fx   movement mass   2 0 *time_delta 
			const double sy    movement vy     time_delta*movement fy   movement mass   2 0 *time_delta 

			position mod_x sx  
			position mod_y sy  

			movement mod_velocity_x time_delta*movement fx   movement mass    
			movement mod_velocity_y time_delta*movement fy   movement mass    

			movement set_force_x 0  
			movement set_force_y 0  
    	 
    	else
    	 
    	 
	   
 


 *


void RenderingSystem::add_id const EntityID entity 
 
	if entity_system   entity entity  
	 
		const int layer   entity_system   entity entity  visuals   layer   
		const auto it   std::find_if cbegin entities[layer]   cend entities[layer]   [entity] const EntityID id    return id    entity     

		if it    cend entities[layer]  
			entities[layer] push_back entity  
	 
	else
	 
	 
 

void RenderingSystem::remove_id const EntityID entity 
 
	if entity_system   entity entity  
	 
		const int layer   entity_system   entity entity  visuals   layer   
		const auto it   std::find_if cbegin entities[layer]   cend entities[layer]   [entity] const EntityID id    return id    entity     

		if it    cend entities[layer]  
			entities[layer] erase it  
	 
	else
	 
	 
 

void RenderingSystem::set_entity_layer const EntityID entity_id  const Visuals::VisualLayer layer 
 
	if entity_system   entity entity_id  
	 
		Visuals* visuals   entity_system   entity entity_id  visuals   
		if layer    visuals layer   
		 
			remove_id entity_id  
			visuals set_layer layer  
			add_id entity_id  
		 
	 
	else
	 
	 
 

void RenderingSystem::render_entities const Time time_diff  const bool paused  SDL_Renderer* renderer  const
 
    SDL_SetRenderDrawColor renderer  255  255  255  255  
    SDL_RenderClear renderer  

    const Position* screen_zone_position   entity_system   entity 0    entity_system   entity 0  position   : Position::null 

    const double m_screen_to_view_scale   screen_zone_position h     1 0*globals   resolution_y screen_zone_position h   : 1 0 

    for auto layer   0  layer < Visuals::NUM_OF_LAYERS    layer 
     
    	std::for_each cbegin entities[layer]   cend entities[layer]  
    	[&] const EntityID id 
		 
			if entity_system   entity id  
			 
				Entity& entity   * entity_system   entity id   
				Visuals* visuals   entity visuals   
				const Movement* movement   entity movement   
				const Position* position   entity position   
				const Control* control   entity control   

				if paused    false 
				 
					Collision* collision   entity collision   
					Health* health   entity health   

					switch visuals state   
					 
						case Visuals::IDLE:
							if health alive      false  visuals set_new_state Visuals::DEAD  
							else if health stunned    visuals set_new_state Visuals::HIT  
							else if control decision_attack    visuals set_new_state Visuals::ATTACK  
							else if collision standing_on    Collision::GROUND && control decision_jump    visuals set_new_state Visuals::JUMP  
							else if collision standing_on    Collision::GROUND && control decision_walk      0  visuals set_new_state Visuals::WALK  
							else if collision standing_on    Collision::AIR && movement vy   < -1  visuals set_new_state Visuals::FALL  
							else visuals advance_animation time_diff  
						break 

						case Visuals::WALK:
							if health alive      false  visuals set_new_state Visuals::DEAD  
							else if health stunned    visuals set_new_state Visuals::HIT  
							else if control decision_attack    visuals set_new_state Visuals::ATTACK  
							else if collision standing_on    Collision::GROUND && control decision_jump    visuals set_new_state Visuals::JUMP  
							else if collision standing_on    Collision::GROUND && control decision_walk      0  visuals set_new_state Visuals::IDLE  
							else if collision standing_on    Collision::AIR && movement vy   < -1  visuals set_new_state Visuals::FALL  
							else visuals advance_animation time_diff  
						break 

						case Visuals::JUMP:
							if health alive      false  visuals set_new_state Visuals::DEAD  
							else if health stunned    visuals set_new_state Visuals::HIT  
							else if control decision_attack    visuals set_new_state Visuals::ATTACK  
							else if collision standing_on    Collision::GROUND && control decision_walk      0  visuals set_new_state Visuals::WALK  
							else if collision standing_on    Collision::GROUND && control decision_walk      0  visuals set_new_state Visuals::IDLE  
							else if collision standing_on    Collision::AIR && movement vy   < -1 && visuals animation_count_max    visuals set_new_state Visuals::FALL  
							else visuals advance_animation time_diff  
						break 

						case Visuals::FALL:
							if health alive      false  visuals set_new_state Visuals::DEAD  
							else if health stunned    visuals set_new_state Visuals::HIT  
							else if control decision_attack    visuals set_new_state Visuals::ATTACK  
							else if collision standing_on    Collision::GROUND && control decision_walk      0  visuals set_new_state Visuals::WALK  
							else if collision standing_on    Collision::GROUND && control decision_walk      0  visuals set_new_state Visuals::IDLE  
							else visuals advance_animation time_diff  
						break 

						case Visuals::ATTACK:
							if health alive      false  visuals set_new_state Visuals::DEAD  
							else if health stunned    visuals set_new_state Visuals::HIT  
							else if visuals animation_count_max   && collision standing_on    Collision::AIR && movement vy   < -1  visuals set_new_state Visuals::FALL  
							else if visuals animation_count_max   && collision standing_on    Collision::GROUND && control decision_jump    visuals set_new_state Visuals::JUMP  
							else if visuals animation_count_max   && collision standing_on    Collision::GROUND && control decision_walk      0  visuals set_new_state Visuals::WALK  
							else if visuals animation_count_max    visuals set_new_state Visuals::IDLE  
							else visuals advance_animation time_diff  
						break 

						case Visuals::HIT:
							if health alive      false  visuals set_new_state Visuals::DEAD  
							else if visuals animation_count_max   && control decision_attack    visuals set_new_state Visuals::ATTACK  
							else if visuals animation_count_max   && collision standing_on    Collision::AIR && movement vy   < -1  visuals set_new_state Visuals::FALL  
							else if visuals animation_count_max   && collision standing_on    Collision::GROUND && control decision_jump    visuals set_new_state Visuals::JUMP  
							else if visuals animation_count_max   && collision standing_on    Collision::GROUND && control decision_walk      0  visuals set_new_state Visuals::WALK  
							else if visuals animation_count_max   && collision standing_on    Collision::GROUND && control decision_walk      0  visuals set_new_state Visuals::IDLE  
							else visuals advance_animation time_diff  
						break 

						case Visuals::DEAD:
							if visuals animation_count_max      false 
								visuals advance_animation time_diff  
						break 

						default:
							visuals advance_animation time_diff  
						break 
					 
				 

				const optional_ref<Spritesheet> spritesheet   resource_system   spritesheet visuals spritesheet_id    
				if spritesheet 
				 
					double scale_factor   spritesheet scale_factor   
					const SDL_RendererFlip flip    control look_dir    Control::LEFT    SDL_RendererFlip::SDL_FLIP_HORIZONTAL : SDL_RendererFlip::SDL_FLIP_NONE 
					AbsolutePosition screen_pos 
					SDL_Rect dest 

					for int16_t rx   0  rx < visuals repeat_x      rx 
						for int16_t ry   0  ry < visuals repeat_y      ry 
						 
							const optional_ref<const Sprite> sprite   spritesheet sprite visuals animation_sprite rx  ry   
							if sprite 
							 
								if resource_system   texture sprite texture_id  
								 
									SDL_Texture* texture   resource_system   texture sprite texture_id  texture   
									screen_pos set_w sprite clip w*scale_factor  
									screen_pos set_h sprite clip h*scale_factor  
									screen_pos set_x position x     position w   visuals repeat_x   2 0 - screen_pos w   2 0   rx*screen_pos w   - screen_zone_position x    
									screen_pos set_y position y     position h   visuals repeat_y   2 0 - screen_pos h   2 0   ry*screen_pos h   - screen_zone_position y    
									dest w   screen_pos w  *m_screen_to_view_scale 
									dest h   screen_pos h  *m_screen_to_view_scale 
									dest x   screen_pos x  *m_screen_to_view_scale 
									dest y   globals   resolution_y - dest h - screen_pos y  *m_screen_to_view_scale 

									if objects_collide dest x  dest y  dest w  dest h  0  0  globals   resolution_x  globals   resolution_y  
									 
										const int err   SDL_RenderCopyEx renderer  texture  &sprite clip  &dest  0  nullptr  flip  
										if err 
										 
											std::cerr << "Error when rendering: " << SDL_GetError   << std::endl 
										 
									 
								 
								else
								 
								 

							 
							else
							 
							 
						 
					if globals   show_hitboxes 
					 
						const SDL_Rect hitbox
							  int entity position   x   - screen_zone_position x   
							  int globals   resolution_y-entity position   h   - entity position   y     screen_zone_position y   
							  int entity position   w   
							  int entity position   h   
							  
						SDL_SetRenderDrawColor renderer  0  0  0  255  
						SDL_RenderDrawRect renderer  &hitbox  
					 
				 
				else
				 
				 
			 
			else
			 
			 
    	   
     

    SDL_RenderPresent renderer  

 
 *


void CollisionSystem::update const Time time_diff 
 
	const std::unordered_map<EntityID  bool> entity_last_triggered  entities_last_triggered_reset    

	for auto it0   entities begin    it0    entities end      it0 
        for auto it1   std::next it0   it1    entities end      it1 
         
        	if entity_system   entity *it0  && entity_system   entity *it1  
        	 
				Entity& entity0   * entity_system   entity *it0   
				Entity& entity1   * entity_system   entity *it1   
				Collision* collision0   entity0 collision   
				Collision* collision1   entity1 collision   

				double x0   entity0 position   x   
				double y0   entity0 position   y   
				double x3   entity1 position   x     entity1 position   w   
				double y3   entity1 position   y     entity1 position   h   
				double sx   entity0 position   x     entity0 position   w     entity1 position   w   
				double sy   entity0 position   y     entity0 position   h     entity1 position   h   

				if objects_collide entity0 position   x    entity0 position   y    entity0 position   w    entity0 position   h  
								   entity1 position   x    entity1 position   y    entity1 position   w    entity1 position   h  
								   
				   
				 
					Interaction* interaction0   entity0 interaction   
					Interaction* interaction1   entity1 interaction   

					if interaction1 is_in_group interaction0 trigger_group    
					 
						interaction0 set_triggered true  
						if interaction0 proc_id_other   >  0 
						 
							command_queue   push std::make_unique<SelectEntityCommand> entity1 id     
							command_queue   push std::make_unique<CallProcedureCommand> interaction0 proc_id_other     
						 
					 

					if interaction0 is_in_group interaction1 trigger_group    
					 
						interaction1 set_triggered true  
						if interaction1 proc_id_other   >  0 
						 
							command_queue   push std::make_unique<SelectEntityCommand> entity0 id     
							command_queue   push std::make_unique<CallProcedureCommand> interaction1 proc_id_other     
						 
					 

					entity0 health   mod_hp_change -collision1 on_collision_damage  *time_diff  
					entity1 health   mod_hp_change -collision0 on_collision_damage  *time_diff  

					bool objects_collide    collision0 state   >  Collision::MOVEABLE 
										&&  collision1 state   >  Collision::MOVEABLE 
										&&  collision0 state      collision1 state    

					if objects_collide 
					 
						Entity& moving_entity   collision0 state      Collision::MOVEABLE   entity0 : entity1 
						double dx   time_diff* entity0 movement   vx   - entity1 movement   vx    
						double dy   time_diff* entity0 movement   vy   - entity1 movement   vy    
						double t 

						t   lines_cross x3  y3  dx  dy  x0  sy  sx-x0  0  
						if t >  0 0 
						 
							moving_entity position   mod_y -sign moving_entity movement   vy   * sy-y3   
							moving_entity movement   set_velocity_y 0  
							if entity1 id      moving_entity id   
							 
								moving_entity collision   set_standing_on Collision::GROUND  
								moving_entity movement   mod_force_x 0 02*dx time_diff  
							 
						 
						else
						 
							t   lines_cross x3  y3  dx  dy  x0  y0  0  sy-y0  
							if t >  0 0 
							 
								moving_entity position   mod_x -sign moving_entity movement   vx   * x3-x0   
								moving_entity movement   set_velocity_x 0  
						    
							else
							 
								t   lines_cross x3  y3  dx  dy  x0  y0  sx-x0  0  
								if t >  0 0 
								 
									moving_entity position   mod_y -sign moving_entity movement   vy   * y3-y0   
									moving_entity movement   set_velocity_y 0  
									if entity0 id      moving_entity id   
									 
										moving_entity collision   set_standing_on Collision::GROUND  
										moving_entity movement   mod_force_x -0 02*dx time_diff  
									 
								 
								else
								 
									t   lines_cross x3  y3  dx  dy  sx  y0  0  sy-y0  
									if t >  0 0 
									 
										moving_entity position   mod_x -sign moving_entity movement   vx   * sx-x3   
										moving_entity movement   set_velocity_x 0  
									 
									else
									 
										std::cerr << "Error" << std::endl 
									 
								 
							 
						 
					 
				 
        	 
        	else
        	 
        	 
         

	std::for_each cbegin entities   cend entities  
	[&] const EntityID id 
	 
		if entity_system   entity id  
		 
			const auto it   entity_last_triggered find id  
			if it    cend entity_last_triggered  
			 
				const Interaction* interaction   entity_system   entity id  interaction   
				const bool entity_last_triggered   it second 
				if entity_last_triggered > interaction triggered   
				 	  was triggered  now it is not  so execute on_exit_proc_self
					if interaction on_exit_proc_id_self   >  0 
					 
						command_queue   push std::make_unique<SelectEntityCommand> id   
						command_queue   push std::make_unique<CallProcedureCommand> interaction on_exit_proc_id_self     
					 
				 
				else
				if entity_last_triggered < interaction triggered   
				 	  was not triggered  now it is  so execute proc_self
					if interaction proc_id_self   >  0 
					 
						command_queue   push std::make_unique<SelectEntityCommand> id   
						command_queue   push std::make_unique<CallProcedureCommand> interaction proc_id_self     
					 
				 

			 
		 
		else
		 
		 
	   
 

std::unordered_map<EntityID  bool> CollisionSystem::entities_last_triggered_reset  
 
	std::unordered_map<EntityID  bool> entities_last_triggered 

	std::for_each cbegin entities   cend entities  
	[&] const EntityID id 
	 
		if entity_system   entity id  
		 
			Entity& entity   * entity_system   entity id   
			entity collision   set_standing_on Collision::AIR  
			entities_last_triggered insert  id  entity interaction   triggered     
	    	entity interaction   set_triggered false  
		 
		else
		 
		 
	   

	return entities_last_triggered 
 

 *


void DamageSystem::update const Time time_diff 
 
	std::for_each cbegin entities   cend entities  
	[time_diff] const EntityID id 
	 
    	if entity_system   entity id  
    	 
    		Entity& entity   * entity_system   entity id   
			Health* health   entity health   
			const bool was_alive   health alive   
			health update_health time_diff  
			if was_alive && health alive      false && health on_death_exec   >  0 
			 
				command_queue   push std::make_unique<SelectEntityCommand> entity id     
				command_queue   push std::make_unique<CallProcedureCommand> health on_death_exec     
			 
    	 
    	else
    	 
    	 
	   
 

 *


void CommandQueue::process Time time_diff 
 
    auto it   m_commands begin   
    while it    m_commands end   
     
		m_curr_cmd_it   it 
		 *it  execute   
		it   m_commands erase it  
     
 

 *



int main int argc  char** argv 
 
	do
	 
		std::ifstream file 
		file open "settings txt"  

		while file peek      EOF 
		 
			const std::string token   [&]    std::string result  file >> result  return result        

			if token    "ResolutionX" 
			 
				file >> globals   resolution_x 
				std::cout << "Set ResolutionX to " << globals   resolution_x << std::endl 
			 
			else if token    "ResolutionY" 
			 
				file >> globals   resolution_y 
				std::cout << "Set ResolutionY to " << globals   resolution_y << std::endl 
			 
			else if token    "Fullscreen" 
			 
				file >> globals   fullscreen 
				std::cout << "Set Fullscreen to " << globals   fullscreen << std::endl 
			 
			else if token    "Level" 
			 
				file >> globals   level_name 
				std::cout << "Set level to " << globals   level_name << std::endl 
			 
			else
				std::cout << "Unknown setting " << token << std::endl 
		 

		file close   

		SdlWindow sdl 
		sdl init_video globals   resolution_x
					   globals   resolution_y
					   globals   fullscreen
					   true  

		int32_t start_frame_time 
		int32_t last_frame_time 
		int32_t frame_diff   10    TODO: first frame difference
		int32_t number_of_frames   0 

		command_queue   push std::make_unique<ExecuteFileCleanCommand> globals   level_name  sdl renderer     

		start_frame_time   SDL_GetTicks   
		last_frame_time   SDL_GetTicks   

		do
		 
			input_handler   process_input   
			command_queue   process frame_diff  
			entity_system   clean_removed_entites   

			if globals   app_paused    false 
			 
				control_system   update frame_diff  
				movement_system   update frame_diff  
				collision_system   update frame_diff  
				damage_system   update frame_diff  
			 

			rendering_system   render_entities frame_diff  globals   app_paused  sdl renderer    

			SDL_Delay max 10-frame_diff  0   
			frame_diff   clip int32_t SDL_GetTicks  -last_frame_time   1  100  
			last_frame_time   SDL_GetTicks   
			  number_of_frames 

			if globals   app_running    false    globals   app_needs_reload 
			 
				resource_system   clear      cleanup textures otherwise when SdlWindow is destroyed we get a memory leak
				control_system   clear   
				movement_system   clear   
				collision_system   clear   
				damage_system   clear   
				rendering_system   clear   
				command_queue   flush_commands   
				entity_system   clear   

				break 
			 
		  while 1  

		std::cout << "FPS   " << 1000 0*number_of_frames    SDL_GetTicks  -start_frame_time  << std::endl 
		globals   app_needs_reload   false 

	  while globals   app_running  

	return 0 
 

 *


InputHandler& input_handler  
 
	static InputHandler input_handler 
	return input_handler 
 

CommandQueue& command_queue  
 
	static CommandQueue command_queue 
	return command_queue 
 

EntitySystem& entity_system  
 
	static EntitySystem entity_system 
	return entity_system 
 

ResourceSystem& resource_system  
 
	static ResourceSystem resources_system 
	return resources_system 
 

ControlSystem& control_system  
 
	static ControlSystem control_system 
	return control_system 
 

MovementSystem& movement_system  
 
	static MovementSystem movement_system 
	return movement_system 
 

CollisionSystem& collision_system  
 
	static CollisionSystem collision_system 
	return collision_system 
 

DamageSystem& damage_system  
 
	static DamageSystem damage_system 
	return damage_system 
 

RenderingSystem& rendering_system  
 
	static RenderingSystem rendering_system 
	return rendering_system 
 

Globals& globals  
 
	static Globals globals 
	return globals 
 
 *


void InputHandler::process_input  
 
	m_up_pressed   false 
	m_down_pressed   false 
	m_select_pressed   false 

    while SDL_PollEvent &m_event     0 
     
        switch m_event type 
         
            case SDL_QUIT:
                globals   app_running   false 
            break 

            case SDL_KEYDOWN:
                if m_event key keysym sym    m_keyjump 
                 
                    m_jump_pressed   true 
                    m_up_pressed   true 
                 
                else if m_event key keysym sym    m_keydown 
                 
                	m_duck_pressed   true 
                    m_down_pressed   true 
                 
                else if m_event key keysym sym    m_keyleft 
                    m_left_pressed   true 
                else if m_event key keysym sym    m_keyright 
                    m_right_pressed   true 
                else if m_event key keysym sym    m_keyshoot 
                    m_shoot_pressed   true 
                else if m_event key keysym sym    m_keyselect 
                    m_select_pressed   true 
                else if m_event key keysym sym    m_keyquit 
                    command_queue   push std::make_unique<QuitCommand>    
                else if m_event key keysym sym    SDLK_r 
                    globals   app_needs_reload   true 
                else if m_event key keysym sym    m_keypause 
                    globals   app_paused    globals   app_paused 
                else if m_event key keysym sym    SDLK_h 
                    globals   show_hitboxes    globals   show_hitboxes 
            break 

            case SDL_KEYUP:
                if m_event key keysym sym    m_keyjump 
                    m_jump_pressed   false 
                else if m_event key keysym sym    m_keydown 
                    m_duck_pressed   false 
                else if m_event key keysym sym    m_keyleft 
                    m_left_pressed   false 
                else if m_event key keysym sym    m_keyright 
                    m_right_pressed   false 
                else if m_event key keysym sym    m_keyshoot 
                    m_shoot_pressed   false 
            break 
         
     
 

 *


SdlWindow::~SdlWindow  
 
	SDL_DestroyWindow m_window  
	SDL_DestroyRenderer m_renderer  

	SDL_Quit   
 

void SdlWindow::init_video const uint16_t res_width
						    const uint16_t res_height
						    const bool fullscreen
						    const bool double_buffer
					 
 
	if m_window 
	 
		SDL_DestroyWindow m_window  
		SDL_DestroyRenderer m_renderer  
		IMG_Quit   
		TTF_Quit   
		SDL_Quit   

		m_window   nullptr 
		m_renderer   nullptr 
	 

	if SDL_Init SDL_INIT_VIDEO  < 0 
	 
		std::cerr << "Unable to init SDL " << SDL_GetError   << std::endl 
		return 
	 

    if IMG_Init IMG_INIT_PNG     IMG_INIT_PNG 
     
        std::cerr << "Unable to initialize SDL_image" << IMG_GetError   << std::endl 
        return 
     

    if TTF_Init   < 0 
     
        std::cerr << "Unable to initialize SDL_ttf" << TTF_GetError   << std::endl 
        return 
     

	atexit SDL_Quit  

	const uint32_t requested_size   res_width * res_height 
	uint32_t closest_size_diff   -1 
	uint16_t final_res_w   res_width  final_res_h   res_height 

    for int display_mode_i   0  display_mode_i < SDL_GetNumDisplayModes 0     display_mode_i 
     
        SDL_DisplayMode mode     SDL_PIXELFORMAT_UNKNOWN  0  0  0  0   
        if  SDL_GetDisplayMode 0  display_mode_i  &mode     0 
         
            std::cerr << "SDL_GetDisplayMode failed: " << SDL_GetError   << std::endl 
            return 
         

        const int32_t size_diff   requested_size   mode w*mode h - 2*min int res_width   mode w  * min int res_height   mode h  
		if  closest_size_diff    -1      size_diff < closest_size_diff  
		 
			closest_size_diff   size_diff 
			final_res_w   mode w 
			final_res_h   mode h 
		 
     
    std::cout << "Chosen resolution is " << final_res_w << " by " << final_res_h << std::endl 

	uint32_t flags   SDL_WINDOW_OPENGL 

	if fullscreen    true  flags    SDL_WINDOW_FULLSCREEN_DESKTOP 

	SDL_CreateWindowAndRenderer final_res_w  final_res_h  flags  &m_window  &m_renderer  

	if  m_window     m_renderer 
	 
		std::cerr << "Unable to initialize video " << SDL_GetError   << std::endl 
		return 
	 

	globals   resolution_x   final_res_w 
	globals   resolution_y   final_res_h 

	SDL_SetRenderDrawColor m_renderer  255  255  255  255  
	SDL_SetRenderDrawBlendMode m_renderer  SDL_BLENDMODE_BLEND  
	SDL_SetWindowTitle m_window  "Game"  

	std::cout << "Video initialized" << std::endl 
 

 *


Health* Health::null new NullHealth    
 *


Visuals* Visuals::null new NullVisuals    
 *


Interaction* Interaction::null new NullInteraction    
 *


void InputControl::update_decisions int32_t time_diff 
 
	m_current_shoot_cooldown   max m_current_shoot_cooldown-time_diff  0  

    m_jump   m_input jumping   &&  m_input ducking   
    m_duck   m_input ducking   
    m_walk_dir   m_input going_right   - m_input going_left   

	m_look_dir   m_walk_dir > 0   RIGHT : m_walk_dir < 0   LEFT : m_look_dir 

	if m_walk_dir    0 && abs entity_system   entity m_self_id  movement   vx    > entity_system   entity m_self_id  movement   move_force   entity_system   entity m_self_id  movement   mass   
     
    	m_walk_dir   -sign entity_system   entity m_self_id  movement   vx    
     

    m_shoot   m_input shooting   &&  m_current_shoot_cooldown    0  

    if m_shoot 
    	m_current_shoot_cooldown   m_shoot_cooldown 
 
 *


double AttachedPosition::x   const
 
	if entity_system   entity m_attached_id  
	 
	    return entity_system   entity m_attached_id  position   x  
	    	   absolute_or_scaled m_offset_x  entity_system   entity m_attached_id  position   w    
	 
	else
	 
		return 0 
	 
 

double AttachedPosition::y   const
 
	if entity_system   entity m_attached_id  
	 
		return entity_system   entity m_attached_id  position   y  
		  absolute_or_scaled m_offset_y  entity_system   entity m_attached_id  position   h    
	 
	else
	 
		return 0 
	 
 

double AttachedPosition::w   const
 
	if entity_system   entity m_attached_id  
	 
		return entity_system   entity m_attached_id  position   w  
			   absolute_or_scaled m_offset_w  entity_system   entity m_attached_id  position   w    
	 
	else
	 
		return 0 
	 
 

double AttachedPosition::h   const
 
	if entity_system   entity m_attached_id  
	 
		return entity_system   entity m_attached_id  position   h  
			   absolute_or_scaled m_offset_h  entity_system   entity m_attached_id  position   h    
	 
	else
	 
		return 0 
	 
 

 *


void GuideControl::update_decisions Time time_diff 
 
	if entity_system   entity m_target_id  
	 
		Position* target_position   entity_system   entity m_target_id  position   
		Position* self_position   entity_system   entity m_self_id  position   
		double distance_x   target_position x   - self_position x      target_position w   - self_position w    2 0 
		double distance_y   target_position y   - self_position y      target_position h   - self_position h    2 0 

		m_walk_dir   sign distance_x  *  abs distance_x  > m_attack_range  
		m_look_dir   distance_x > 0   RIGHT : distance_x < 0   LEFT : m_look_dir 

		m_jump   distance_y > 100 && distance_y < 200 && abs distance_x  < 200 
	 
	else
	 
	 
 




 *


Movement* Movement::null new NullMovement    
 *


uint8_t CharacterHealthVisuals::animation_sprite uint16_t rx  uint16_t ry  const
 
	if entity_system   entity m_self_id  
	 
		Health* health   entity_system   entity m_self_id  health   
		return  m_repeat_x    0  &&  health max_hp      0  &&  1 0*rx m_repeat_x  <  1 0*health hp   health max_hp    
	 
	else
	 
		return 0 
	 
 
 *


double AttachedHealth::hp   const
 
	if entity_system   entity m_attached_id  
	 
		return entity_system   entity m_attached_id  health   hp     m_offset_hp 
	 
	else
	 
		return 0 
	 
 

double AttachedHealth::max_hp   const
 
	if entity_system   entity m_attached_id  
	 
		return entity_system   entity m_attached_id  health   max_hp     m_offset_max_hp 
	 
	else
	 
		return 0 
	 
 
 *


Collision* Collision::null new NullCollision    
 *


uint8_t MenuItemVisuals::animation_sprite uint16_t rx  uint16_t ry  const
 
	if entity_system   entity m_self_id  
	 
		Control* control   entity_system   entity m_self_id  control   
		return control decision_attack     2 : control decision_jump     1 : 0 
	 
	else
	 
		return 0 
	 
 
 *


uint8_t CharacterVisuals::animation_state_size   const
 
    switch m_current_state 
     
        case IDLE:
        	return resource_system   spritesheet m_spritesheet_id  idle_sprite_size   
        case WALK:
        	return resource_system   spritesheet m_spritesheet_id  walk_sprite_size   
        case JUMP:
        	return resource_system   spritesheet m_spritesheet_id  jump_sprite_size   
        case FALL:
        	return resource_system   spritesheet m_spritesheet_id  fall_sprite_size   
        case ATTACK:
        	return resource_system   spritesheet m_spritesheet_id  attack_sprite_size   
        case HIT:
        	return resource_system   spritesheet m_spritesheet_id  hit_sprite_size   
        case DEAD:
        	return resource_system   spritesheet m_spritesheet_id  dead_sprite_size   
        default:
        	return 0 
     
 

uint8_t CharacterVisuals::animation_state_offset   const
 
    switch m_current_state 
     
        case IDLE:
            return resource_system   spritesheet m_spritesheet_id  idle_sprite_start   
        case WALK:
            return resource_system   spritesheet m_spritesheet_id  walk_sprite_start   
        case JUMP:
            return resource_system   spritesheet m_spritesheet_id  jump_sprite_start   
        case FALL:
            return resource_system   spritesheet m_spritesheet_id  fall_sprite_start   
        case ATTACK:
            return resource_system   spritesheet m_spritesheet_id  attack_sprite_start   
        case HIT:
            return resource_system   spritesheet m_spritesheet_id  hit_sprite_start   
        case DEAD:
            return resource_system   spritesheet m_spritesheet_id  dead_sprite_start   
        default:
            return 0 
     
 


 *


Position* Position::null new NullPosition    
 *


Control* Control::null new NullControl    
 *


void ChaseAIControl::update_decisions Time time_diff 
 
	m_current_attack_cooldown   max m_current_attack_cooldown-time_diff  0  

	if entity_system   entity m_target_id  
	 
		Position* target_position   entity_system   entity m_target_id  position   
		Position* self_position   entity_system   entity m_self_id  position   
		double distance_x   target_position x   - self_position x      target_position w   - self_position w    2 0 
		double distance_y   target_position y   - self_position y      target_position h   - self_position h    2 0 

		m_walk_dir   sign distance_x  *  abs distance_x  > m_attack_range  
		m_look_dir   distance_x > 0   RIGHT : distance_x < 0   LEFT : m_look_dir 
		m_attack    m_attack_proc_id >  0  &&  abs distance_x  <  m_attack_range  &&  abs distance_y  <  30  &&  m_current_attack_cooldown    0  

		if m_attack 
			m_current_attack_cooldown   m_attack_cooldown 
	 
	else
	 
	 
 

 *


void Spritesheet::add_sprite TextureID tex_index  int x  int y  int w  int h 
 
    if tex_index < resource_system   textures   size   
     
        m_sprites push_back  tex_index   x  y  w  h    
     
    else
     
     
 

 *


void UseTiledVisualsCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_visuals new TiledVisuals m_spr_id  m_repeat_x  m_repeat_y   
	else
	 
	 
 
 *


void ModifyInteractionCommand::execute   const
 
	if entity_system   previous_entity   
	 
		Interaction* interaction   entity_system   previous_entity   interaction   

		if is_negative_zero m_group  
			interaction clear_groups   
		else
			if is_negative_zero m_value  
				interaction set_group m_group  false  
			else
				interaction set_group m_group  bool m_value    interaction is_in_group m_group   

		if is_negative_zero m_trigger_group  
			interaction set_trigger_group 0  
		else
			interaction set_trigger_group interaction trigger_group     m_trigger_group  

		if is_negative_zero m_proc_id_self  
			interaction set_proc_id_self 0  
		else
			interaction set_proc_id_self interaction proc_id_self     m_proc_id_self  

		if is_negative_zero m_proc_id_other  
			interaction set_proc_id_other 0  
		else
			interaction set_proc_id_other interaction proc_id_other     m_proc_id_other  

		if is_negative_zero m_on_exit_proc_id_self  
			interaction set_on_exit_proc_id_self 0  
		else
			interaction set_on_exit_proc_id_self interaction on_exit_proc_id_self     m_on_exit_proc_id_self  
	 
	else
	 
	 
 
 *


void UseCharacterVisualsCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_visuals new CharacterVisuals m_spr_id   
	else
	 
	 
 
 *


void UseConstantControlCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_control new ConstantControl m_move_decision  m_jump_decision  m_duck_decision  m_look_dir   
	else
	 
	 
 
 *


void ExtendProcedureCommand::execute   const
 
    if resource_system   procedure m_id  
     
		for int i   0  i < m_num_of_cmds    i 
		 
			std::unique_ptr<Command> cmd   command_queue   pop_next   
			resource_system   procedure m_id  add_command std::move cmd   
		 
     
    else
     
     
 
 *


void ModifyVisualsCommand::execute   const
 
	if entity_system   previous_entity   
	 
		Visuals* visuals   entity_system   previous_entity   visuals   

		if is_negative_zero m_render_state  
			visuals set_new_state Visuals::IDLE  
		else
			visuals set_new_state Visuals::RenderStates  visuals state     int m_render_state   6   

		if is_negative_zero m_repeat_x  
			visuals set_repeat_x 0  
		else
			visuals set_repeat_x visuals repeat_x   int m_repeat_x   

		if is_negative_zero m_repeat_y  
			visuals set_repeat_y 0  
		else
			visuals set_repeat_y visuals repeat_y   int m_repeat_y   

		if is_negative_zero m_spr_id  
			visuals set_spritesheet_id 0  
		else
			visuals set_spritesheet_id visuals spritesheet_id   int m_spr_id   

		if is_negative_zero m_layer  
		 
			if visuals layer      0 
			 
				rendering_system   remove_id entity_system   previous_entity   id    
				visuals set_layer Visuals::VisualLayer 0   
				rendering_system   add_id entity_system   previous_entity   id    
			 
		 
		else
		 
			if m_layer    0 
			 
				rendering_system   remove_id entity_system   previous_entity   id    
				visuals set_layer Visuals::VisualLayer visuals layer   int m_layer    
				rendering_system   add_id entity_system   previous_entity   id    
			 
		 
	 
	else
	 
	 
 
 *


void ExecuteFileCommand::execute   const
 
	std::ifstream file_read m_filename  
    std::string line 
    std::unique_ptr<Command> command 
    double vars[15] 

    while file_read good   
     
    	const std::string token   [&]    std::string result  file_read >> result  return result        
        if file_read eof   
            break 

        std::cout << "Token is '" << token << "'" << std::endl 
        if token[0]    '#' 
         
            std::getline file_read  line  
            std::cout << "Reading comment: " << token << line << std::endl 
         
        else if token    "Null" 
         
            command   std::make_unique<NullCommand>   
         
        else if token    "DebugMessage" 
         
        	file_read >> vars[0] 
            std::getline file_read  line  
        	command   std::make_unique<DebugMessageCommand> line  DebugMessageCommand::Severity vars[0]   
         
        else if token    "SetLevel" 
         
        	file_read >> line 
            command   std::make_unique<SetLevelCommand> line  
         
        else if token    "FixViewWidth" 
         
            command   std::make_unique<FixViewWidthCommand>   
         
        else if token    "SelectEntity" 
         
        	file_read >> vars[0] 
            command   std::make_unique<SelectEntityCommand> EntityID vars[0]   
         
        else if token    "ExtendProcedure" 
         
        	file_read >> vars[0] 
        	file_read >> vars[1] 
            command   std::make_unique<ExtendProcedureCommand> ProcedureID vars[0]   int vars[1]   
         
        else if token    "ClearProcedure" 
         
        	file_read >> vars[0] 
            command   std::make_unique<ClearProcedureCommand> ProcedureID vars[0]   
         
        else if token    "Pause" 
         
        	file_read >> vars[0] 
            command   std::make_unique<PauseCommand> bool vars[0]   
         
        else if token    "Quit" 
         
            command   std::make_unique<QuitCommand>   
         
        else if token    "ClearAllEntities" 
         
            command   std::make_unique<ClearAllEntitiesCommand>   
         
        else if token    "ClearAllTextures" 
         
            command   std::make_unique<ClearAllTexturesCommand>   
         
        else if token    "ClearAllSpritesheets" 
         
            command   std::make_unique<ClearAllSpritesheetsCommand>   
         
        else if token    "ClearAllProcedures" 
         
            command   std::make_unique<ClearAllProceduresCommand>   
         
        else if token    "ExecuteFile" 
         
        	file_read >> line 
        	command   std::make_unique<ExecuteFileCommand> line  m_renderer  
         
        else if token    "ExecuteFileClean" 
         
        	file_read >> line 
        	command   std::make_unique<ExecuteFileCleanCommand> line  m_renderer  
         
        else if token    "CallProcedure" 
         
        	file_read >> vars[0] 
            command   std::make_unique<CallProcedureCommand> ProcedureID vars[0]   
         
        else if token    "AddFont" 
         
        	file_read >> vars[0] 
        	file_read >> line 
            command   std::make_unique<AddFontCommand> line  int vars[0]   
         
        else if token    "AddTextureFromFile" 
         
        	file_read >> line 
            command   std::make_unique<AddTextureFromFileCommand> line  m_renderer  
         
        else if token    "AddTextureFromString" 
         
        	file_read >> vars[0] 
        	file_read >> vars[1] 
        	file_read >> vars[2] 
        	file_read >> vars[3] 
            std::getline file_read  line  
            command   std::make_unique<AddTextureFromStringCommand> line  FontID vars[0]   uint8_t vars[1]   uint8_t vars[2]   uint8_t vars[3]   m_renderer  
         
        else if token    "AddSpritesheet" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            file_read >> vars[4] 
            file_read >> vars[5] 
            file_read >> vars[6] 
            file_read >> vars[7] 
            file_read >> vars[8] 
            file_read >> vars[9] 
            file_read >> vars[10] 
            file_read >> vars[11] 
            file_read >> vars[12] 
            file_read >> vars[13] 
            file_read >> vars[14] 
            command   std::make_unique<AddSpritesheetCommand> int vars[0]   int vars[1] 
            								    int vars[2]   int vars[3] 
            								    int vars[4]   int vars[5] 
            								    int vars[6]   int vars[7] 
            								    int vars[8]   int vars[9] 
            								    int vars[10]   int vars[11] 
            								    int vars[12]   int vars[13] 
            								    double vars[14] 
            									  
         
        else if token    "AddSprite" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            file_read >> vars[4] 
            file_read >> vars[5] 
            command   std::make_unique<AddSpriteCommand> SpritesheetID vars[0]   TextureID vars[1]   vars[2]  vars[3]  vars[4]  vars[5]  
         
        else if token    "AddProcedure" 
         
        	file_read >> vars[0] 
            command   std::make_unique<AddProcedureCommand> int vars[0]   
         
        else if token    "AddCharacter" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            file_read >> vars[4] 
            file_read >> vars[5] 
            command   std::make_unique<AddCharacterCommand> vars[0]  vars[1]  vars[2]  vars[3]  vars[4]  SpritesheetID vars[5]   
         
        else if token    "AddPlatform" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            file_read >> vars[4] 
            file_read >> vars[5] 
            file_read >> vars[6] 
            command   std::make_unique<AddPlatformCommand> vars[0]  vars[1]  vars[2]  vars[3]  SpritesheetID vars[4]   vars[5]  vars[6]  
         
        else if token    "AddProjectile" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            file_read >> vars[4] 
            command   std::make_unique<AddProjectileCommand> vars[0]  vars[1]  vars[2]  vars[3]  SpritesheetID vars[4]   
         
        else if token    "AddZone" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            file_read >> vars[4] 
            file_read >> vars[5] 
            file_read >> vars[6] 
            file_read >> vars[7] 
            command   std::make_unique<AddZoneCommand> vars[0]  vars[1]  vars[2]  vars[3]  int8_t vars[4]   ProcedureID vars[5]   ProcedureID vars[6]   ProcedureID vars[7]   
         
        else if token    "AddVisualObject" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            file_read >> vars[4] 
            file_read >> vars[5] 
            command   std::make_unique<AddVisualObjectCommand> vars[0]  vars[1]  vars[2]  vars[3]  SpritesheetID vars[4]   int vars[5]   
         
        else if token    "AddEntity" 
         
            command   std::make_unique<AddEntityCommand>   
         
        else if token    "RemoveEntity" 
         
            command   std::make_unique<RemoveEntityCommand>   
         
        else if token    "ModifyPosition" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            command   std::make_unique<ModifyPositionCommand> vars[0]  vars[1]  vars[2]  vars[3]  
         
        else if token    "ModifyControl" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            file_read >> vars[4] 
            command   std::make_unique<ModifyControlCommand> vars[0]  vars[1]  vars[2]  vars[3]  vars[4]  
         
        else if token    "ModifyMovement" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            file_read >> vars[4] 
            file_read >> vars[5] 
            file_read >> vars[6] 
            command   std::make_unique<ModifyMovementCommand> vars[0]  vars[1]  vars[2]  vars[3]  vars[4]  vars[5]  vars[6]  
         
        else if token    "ModifyCollision" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            command   std::make_unique<ModifyCollisionCommand> vars[0]  vars[1]  vars[2]  
         
        else if token    "ModifyInteraction" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            file_read >> vars[4] 
            file_read >> vars[5] 
            command   std::make_unique<ModifyInteractionCommand> vars[0]  vars[1]  vars[2]  vars[3]  vars[4]  vars[5]  
         
        else if token    "ModifyHealth" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            command   std::make_unique<ModifyHealthCommand> vars[0]  vars[1]  vars[2]  
         
        else if token    "ModifyVisuals" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            file_read >> vars[4] 
            command   std::make_unique<ModifyVisualsCommand> vars[0]  vars[1]  vars[2]  vars[3]  vars[4]  
         
        else if token    "UseNullPosition" 
         
            command   std::make_unique<UseNullPositionCommand>   
         
        else if token    "UseAbsolutePosition" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            command   std::make_unique<UseAbsolutePositionCommand> AbsolutePosition vars[0]  vars[1]  vars[2]  vars[3]   
         
        else if token    "UseAttachedPosition" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            file_read >> vars[4] 
            command   std::make_unique<UseAttachedPositionCommand> EntityID vars[0]   vars[1]  vars[2]  vars[3]  vars[4]  
         
        else if token    "UseNullControl" 
         
            command   std::make_unique<UseNullControlCommand>   
         
        else if token    "UseConstantControl" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            command   std::make_unique<UseConstantControlCommand> int8_t vars[0]   bool vars[1]   bool vars[2]   Control::LookDir vars[3]   
         
        else if token    "UseInputControl" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            command   std::make_unique<UseInputControlCommand> ProcedureID vars[0]   vars[1]  
         
        else if token    "UseInputSelectControl" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            command   std::make_unique<UseInputSelectControlCommand> int vars[0]   int vars[1]   ProcedureID vars[2]   
         
        else if token    "UseChaseAIControl" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            command   std::make_unique<UseChaseAIControlCommand> EntityID vars[0]   ProcedureID vars[1]   vars[2]  vars[3]  
         
        else if token    "UseGuideControl" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            command   std::make_unique<UseGuideControlCommand> EntityID vars[0]   ProcedureID vars[1]   vars[2]  vars[3]  
         
        else if token    "UseNullMovement" 
         
            command   std::make_unique<UseNullMovementCommand>   
         
        else if token    "UseFullMovement" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            file_read >> vars[4] 
            command   std::make_unique<UseFullMovementCommand> vars[0]  vars[1]  vars[2]  vars[3]  bool vars[4]   
         
        else if token    "UseInstantMovement" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            command   std::make_unique<UseInstantMovementCommand> vars[0]  vars[1]  vars[2]  
         
        else if token    "UseNullCollision" 
         
            command   std::make_unique<UseNullCollisionCommand>   
         
        else if token    "UseBasicCollision" 
         
            file_read >> vars[0] 
            command   std::make_unique<UseBasicCollisionCommand> Collision::CollisionState vars[0]   
         
        else if token    "UseDamageCollision" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            command   std::make_unique<UseDamageCollisionCommand> Collision::CollisionState vars[0]   vars[1]  
         
        else if token    "UseNullInteraction" 
         
            command   std::make_unique<UseNullInteractionCommand>   
         
        else if token    "UseNormalInteraction" 
         
            file_read >> vars[0] 
            command   std::make_unique<UseNormalInteractionCommand> int32_t vars[0]   
         
        else if token    "UseTriggerInteraction" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            command   std::make_unique<UseTriggerInteractionCommand> int8_t vars[0]   ProcedureID vars[1]   ProcedureID vars[2]   ProcedureID vars[3]   
         
        else if token    "UseFullInteraction" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            file_read >> vars[3] 
            file_read >> vars[4] 
            command   std::make_unique<UseFullInteractionCommand> int32_t vars[0]   int8_t vars[1]   ProcedureID vars[2]   ProcedureID vars[3]   ProcedureID vars[4]   
         
        else if token    "UseNullHealth" 
         
            command   std::move std::make_unique<UseNullHealthCommand>    
         
        else if token    "UseAttachedHealth" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            command   std::make_unique<UseAttachedHealthCommand> EntityID vars[0]   vars[1]  vars[2]  
         
        else if token    "UseCharacterHealth" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            command   std::make_unique<UseCharacterHealthCommand> vars[0]  vars[1]  
         
        else if token    "UseTimedHealth" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            command   std::make_unique<UseTimedHealthCommand> vars[0]  ProcedureID vars[1]   
         
        else if token    "UseNullVisuals" 
         
            command   std::make_unique<UseNullVisualsCommand>   
         
        else if token    "UseCharacterVisuals" 
         
            file_read >> vars[0] 
            command   std::make_unique<UseCharacterVisualsCommand> SpritesheetID vars[0]   
         
        else if token    "UseTiledVisuals" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            file_read >> vars[2] 
            command   std::make_unique<UseTiledVisualsCommand> SpritesheetID vars[0]   uint16_t vars[1]   uint16_t vars[2]   
         
        else if token    "UseStaticVisuals" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            command   std::make_unique<UseStaticVisualsCommand> SpritesheetID vars[0]   int vars[1]   
         
        else if token    "UseHealthVisuals" 
         
            file_read >> vars[0] 
            file_read >> vars[1] 
            command   std::make_unique<UseHealthVisualsCommand> SpritesheetID vars[0]   uint16_t vars[1]   
         
        else if token    "UseMenuItemVisuals" 
         
            file_read >> vars[0] 
            command   std::make_unique<UseMenuItemVisualsCommand> SpritesheetID vars[0]   
         
        else
         
            std::cout << "Error while parsing file " << m_filename << ": Unknown token " << token << std::endl 
         

        if file_read fail   
         
            std::cerr << "Error while parsing file " << m_filename << ": Parameters of token " << token << std::endl 
         
        else
         
        	if command  command_queue   push std::move command   
         
     
 

 *


void ModifyCollisionCommand::execute   const
 
	if entity_system   previous_entity   
	 
		Collision* collision   entity_system   previous_entity   collision   

		if is_negative_zero m_state  
			collision set_state Collision::CollisionState 0   
		else
			collision set_state Collision::CollisionState  int m_state    collision state    3   

		if is_negative_zero m_standing_on  
			collision set_standing_on Collision::AIR  
		else
			collision set_standing_on Collision::SurfaceType  collision standing_on   1  4   

		if is_negative_zero m_on_collision_damage  
			collision set_collision_damage 0  
		else
			collision set_collision_damage collision on_collision_damage     m_on_collision_damage  
	 
	else
	 
	 
 
 *


void UseAttachedPositionCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_position new AttachedPosition resolved_entity m_id   m_offset_x  m_offset_y  m_offset_w  m_offset_h   
	else
	 
	 
 
 *


void DebugMessageCommand::execute   const
 
	if m_severity    ERROR 
		std::cout << m_text << std::endl 
	else
		std::cerr << m_text << std::endl 
 

 *


void UseChaseAIControlCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_control new ChaseAIControl entity_system   previous_entity   id    resolved_entity m_target_id   m_attack_id  m_attack_cooldown  m_attack_range   
	else
	 
	 
 

 *


void AddFontCommand::execute   const
 
	resource_system   addNewFont m_file  m_size  
 
 *


void AddTextureFromFileCommand::execute   const
 
	resource_system   addNewTextureFromFile m_file  m_renderer  
 
 *


void AddProcedureCommand::execute   const
 
	resource_system   addNewProcedure   
    globals   access_procedure_id   resource_system   last_procedure_id   

    if m_num_of_cmds > 0 
     
        ExtendProcedureCommand globals   access_procedure_id  m_num_of_cmds  execute   
     
 
 *


void UseInputSelectControlCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_control new InputSelectControl &input_handler    m_select  m_max  m_proc_id   
	else
	 
	 
 


 *


void UseNormalInteractionCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_interaction new NormalInteraction m_group_vec   
	else
	 
	 
 
 *


void ClearAllEntitiesCommand::execute   const
 
	entity_system   clear   
 

 *


void UseNullInteractionCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_interaction new NullInteraction    
	else
	 
	 
 
 *


void UseFullMovementCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_movement new FullMovement m_mass  m_friction  m_move_force  m_jump_force  m_gravity_affected   
	else
	 
	 
 
 *


void UseTimedHealthCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_health new TimedHealth m_ttl  m_proc_id   
	else
	 
	 
 
 *


void AddSpritesheetCommand::execute   const
 
	resource_system   addNewSpritesheet m_idle_start  m_idle_size
                                              m_walk_start  m_walk_size
                                              m_jump_start  m_jump_size
                                              m_fall_start  m_fall_size
                                              m_attack_start  m_attack_size
                                              m_hit_start  m_hit_size
                                              m_dead_start  m_dead_size
                                              m_scale_factor
                                               
    globals   access_spritesheet_id   resource_system   last_spritesheet_id   
 
 *


void UseNullHealthCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_health new NullHealth    
	else
	 
	 
 
 *


void UseDamageCollisionCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_collision new DamageCollision m_state  m_damage   
	else
	 
	 
 
 *


void UseTriggerInteractionCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_interaction new TriggerInteraction m_trigger_group  m_on_enter_proc_id_self  m_on_enter_proc_id_other  m_on_exit_proc_id_self   
	else
	 
	 
 
 *


void UseMenuItemVisualsCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_visuals new MenuItemVisuals m_spr_id  entity_system   previous_entity   id     
	else
	 
	 
 
 *


void UseNullControlCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_control new NullControl    
	else
	 
	 
 
 *


void UseCharacterHealthCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_health new CharacterHealth m_hp  m_max_hp   
	else
	 
	 
 
 *


void ClearAllProceduresCommand::execute   const
 
	resource_system   clear_procedures   
 
 *


void AddSpriteCommand::execute   const
 
	int width  height 
	if m_w    0    m_h    0 
	 
		if resource_system   texture m_tex_id  
			SDL_QueryTexture resource_system   texture m_tex_id  texture    nullptr  nullptr  &width  &height  
		else
		 
			return 
		 
	 

	width    m_w    0    width  : m_w 
	height    m_h    0    height : m_h 

	resource_system   spritesheet m_spr_id  add_sprite m_tex_id  m_x  m_y  width  height  
 
 *


void UseNullVisualsCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_visuals new NullVisuals    
	else
	 
	 
 
 *


void RemoveEntityCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   remove_entity entity_system   previous_entity   id    
	else
	 
	 
 

 *


void PauseCommand::execute   const
 
    globals   app_paused   m_paused 
 
 *


void ModifyHealthCommand::execute   const
 
	if entity_system   previous_entity   
	 
		Health* health   entity_system   previous_entity   health   

		if is_negative_zero m_max_hp  
			health set_max_hp 0  
		else
			health set_max_hp health max_hp     m_max_hp  

		if is_negative_zero m_hp  
			health set_hp 0  
		else
			health set_hp health hp     m_hp  

		if is_negative_zero m_hp_change  
			health set_hp_change 0  
		else
			health mod_hp_change m_hp_change  
	 
	else
	 
	 
 

 *


void ProcedureCommand::execute   const
 
    for auto it   m_commands rbegin    it    m_commands rend      it 
    	command_queue   insert_next  *it  clone    
 

 *


void CallProcedureCommand::execute   const
 
	if resource_system   procedure m_id  
		resource_system   procedure m_id  execute   
	else
	 
	 
 
 *


void UseFullInteractionCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_interaction new FullInteraction m_group_vec  m_trigger_group  m_on_enter_proc_id_self  m_on_enter_proc_id_other  m_on_exit_proc_id_self   
	else
	 
	 
 
 *


void AddVisualObjectCommand::execute   const
 
	Entity& entity   entity_system   add_new_entity   
	entity set_position new AbsolutePosition m_x  m_y  m_w  m_h   
	entity set_visuals new StaticVisuals m_spr_id  m_sprite   
    entity_system   add_accessed_entity entity id    
 
 *


void UseAttachedHealthCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_health new AttachedHealth resolved_entity m_attached_id   m_offset_hp  m_offset_max_hp   
	else
	 
	 
 
 *


void UseBasicCollisionCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_collision new BasicCollision m_state   
	else
	 
	 
 
 *


void UseInstantMovementCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_movement new InstantMovement m_mass  m_friction  m_move_force   
	else
	 
	 
 
 *


void UseHealthVisualsCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_visuals new CharacterHealthVisuals entity_system   previous_entity   id    m_spr_id  m_repeat_x   
	else
	 
	 
 
 *


void AddTextureFromStringCommand::execute   const
 
	resource_system   addNewTextureFromString m_text  m_font_id  m_r  m_g  m_b  m_renderer  
 
 *


void ModifyMovementCommand::execute   const
 
	if entity_system   previous_entity   
	 
		Movement* movement   entity_system   previous_entity   movement   

		if is_negative_zero m_mass  
			movement set_mass m_mass  
		else
			movement set_mass movement mass     m_mass  

		if is_negative_zero m_friction  
			movement set_friction m_friction  
		else
			movement set_friction movement friction     m_friction  

		if is_negative_zero m_fx  
			movement set_force_x m_fx  
		else
			movement mod_force_x m_fx  

		if is_negative_zero m_fy  
			movement set_force_y m_fy  
		else
			movement mod_force_y m_fy  

		if is_negative_zero m_vx  
			movement set_velocity_x m_vx  
		else
			movement mod_velocity_x m_vx  

		if is_negative_zero m_vy  
			movement set_velocity_y m_vy  
		else
			movement mod_velocity_y m_vy  

		if is_negative_zero m_gravity_affected  
			movement set_gravity_affected bool m_gravity_affected   
		else
			movement set_gravity_affected bool m_gravity_affected    movement gravity_affected    
	 
	else
	 
	 
 
 *


void UseNullMovementCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_movement new NullMovement    
	else
	 
	 
 
 *


void ClearAllTexturesCommand::execute   const
 
	resource_system   clear_textures   
 
 *


void ModifyControlCommand::execute   const
 
	if entity_system   previous_entity   
	 
		Control* control   entity_system   previous_entity   control   

		if is_negative_zero m_decision_jump  
			control set_decision_jump false  
		else
			control set_decision_jump bool m_decision_jump    control decision_jump    

		if is_negative_zero m_decision_duck  
			control set_decision_duck false  
		else
			control set_decision_duck bool m_decision_duck    control decision_duck    

		if is_negative_zero m_decision_attack  
			control set_decision_attack false  
		else
			control set_decision_attack bool m_decision_attack    control decision_attack    

		if is_negative_zero m_decision_walk  
			control set_decision_walk 0  
		else
			control set_decision_walk clip int8_t m_decision_walk    control decision_walk    -1  1   

		if is_negative_zero m_look_dir  
			control set_look_dir Control::RIGHT  
		else
			control set_look_dir Control::LookDir bool m_look_dir    bool control look_dir      
	 
	else
	 
	 
 
 *


void ClearProcedureCommand::execute   const
 
	if resource_system   procedure m_id  
	 
		resource_system   procedure m_id  clear   
	 
	else
	 
	 
 
 *


void AddPlatformCommand::execute   const
 
	Entity& entity   entity_system   add_new_entity   
    entity set_position new AbsolutePosition m_x  m_y  m_w  m_h   
    entity set_collision new BasicCollision Collision::SOLID   
    entity set_visuals new TiledVisuals m_spr_id  m_rx  m_ry   
    entity_system   add_accessed_entity entity id    
 
 *


void SetLevelCommand::execute   const
 
	globals   level_name   m_level 
 
 *


void AddEntityCommand::execute   const
 
	Entity& entity   entity_system   add_new_entity   
    entity_system   add_accessed_entity entity id    
 
 *


void AddCharacterCommand::execute   const
 
	Entity& entity   entity_system   add_new_entity   
    entity set_position new AbsolutePosition m_x  m_y  m_w  m_h   
    entity set_movement new FullMovement 0 5  2  0 012  1 5  true   
    entity set_collision new BasicCollision Collision::MOVEABLE   
    entity set_interaction new NormalInteraction    
    entity set_health new CharacterHealth m_hp   
    entity set_visuals new CharacterVisuals m_spr_id   
    entity_system   add_accessed_entity entity id    
 
 *


void UseStaticVisualsCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_visuals new StaticVisuals m_spr_id  m_sprite   
	else
	 
	 
 
 *


void ModifyPositionCommand::execute   const
 
	if entity_system   previous_entity   
	 
		Position* position   entity_system   previous_entity   position   

		if is_negative_zero m_x  
			position set_x m_x  
		else
			position mod_x m_x  

		if is_negative_zero m_y  
			position set_y m_y  
		else
			position mod_y m_y  

		if is_negative_zero m_w  
			position set_w m_w  
		else
			position mod_w m_w  

		if is_negative_zero m_h  
			position set_h m_h  
		else
			position mod_h m_h  
	 
	else
	 
	 
 
 *


void AddZoneCommand::execute   const
 
	Entity& entity   entity_system   add_new_entity   
	entity set_position new AbsolutePosition m_x  m_y  m_w  m_h   
    entity set_collision new BasicCollision Collision::TRANSPARENT   
    entity set_interaction new TriggerInteraction m_trigger_group  m_on_enter_proc_id_self  m_on_enter_proc_id_other  m_on_exit_proc_id_self   
    entity_system   add_accessed_entity entity id    
 


 *


void SelectEntityCommand::execute   const
 
    entity_system   add_accessed_entity resolved_entity m_id   
 
 *


void UseNullCollisionCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_collision new NullCollision    
	else
	 
	 
 
 *


void UseGuideControlCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_control new GuideControl entity_system   previous_entity   id    resolved_entity m_target_id   m_attack_proc_id  m_attack_cooldown  m_range   
	else
	 
	 
 

 *


void UseNullPositionCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_position new NullPosition    
	else
	 
	 
 
 *


void QuitCommand::execute   const
 
    globals   app_running   false 
 
 *


void FixViewWidthCommand::execute   const
 
	if entity_system   entity 0  
		entity_system   entity 0  position   set_w int entity_system   entity 0  position   h  *globals   resolution_x globals   resolution_y   
	else
	 
	 
 
 *


void ExecuteFileCleanCommand::execute   const
 
	command_queue   flush_commands   
	resource_system   clear   
	control_system   clear   
	movement_system   clear   
	collision_system   clear   
	damage_system   clear   
	rendering_system   clear   
	entity_system   clear   
	command_queue   push std::make_unique<ExecuteFileCommand> m_filename  m_renderer   
 
 *


void AddProjectileCommand::execute   const
 
	Entity& entity   entity_system   add_new_entity   
    entity set_position new AbsolutePosition m_x  m_y  m_w  m_h   
    entity set_control new ConstantControl 1  false  false  Control::RIGHT   
    entity set_movement new FullMovement false   
    entity set_collision new DamageCollision Collision::TRANSPARENT  0 01   
    entity set_visuals new StaticVisuals m_spr_id  0   
    rendering_system   set_entity_layer entity id    Visuals::FOREGROUND  
    entity_system   add_accessed_entity entity id    
 


 *


void ClearAllSpritesheetsCommand::execute   const
 
	resource_system   clear_spritesheets   
 
 *


void UseAbsolutePositionCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_position new AbsolutePosition m_position   
	else
	 
	 
 
 *


void UseInputControlCommand::execute   const
 
	if entity_system   previous_entity   
		entity_system   previous_entity   set_control new InputControl &input_handler    m_shoot_id  m_shoot_cooldown  entity_system   previous_entity   id     
	else
	 
	 
 
 *


Entity::Entity EntityID id 
: m_id id 
  m_position Position::null 
  m_control Control::null 
  m_movement Movement::null 
  m_collision Collision::null 
  m_interaction Interaction::null 
  m_health Health::null 
  m_visuals Visuals::null 
  


void Entity::set_position Position* _position 
 
	release m_position  
	m_position   _position 
 

void Entity::set_control Control* _control 
 
	if m_control    Control::null && _control    Control::null 
	 
		control_system   remove_id id    
		m_control   _control 
	 

	release m_control  

	if m_control    Control::null && _control    Control::null 
	 
		m_control   _control 
		control_system   add_id id    
	 
	else
		m_control   _control 
 

void Entity::set_movement Movement* _movement 
 
	if m_movement    Movement::null && _movement    Movement::null 
	 
		movement_system   remove_id id    
		m_movement   _movement 
	 

	release m_movement  

	if m_movement    Movement::null && _movement    Movement::null 
	 
		m_movement   _movement 
		movement_system   add_id id    
	 
	else
		m_movement   _movement 
 

void Entity::set_collision Collision* _collision 
 
	if m_collision    Collision::null && _collision    Collision::null 
	 
		collision_system   remove_id id    
		m_collision   _collision 
	 

	release m_collision  

	if m_collision    Collision::null && _collision    Collision::null 
	 
		m_collision   _collision 
		collision_system   add_id id    
	 
	else
		m_collision   _collision 
 

void Entity::set_interaction Interaction* _interaction 
 
	release m_interaction  
	m_interaction   _interaction 
 

void Entity::set_health Health* _health 
 
	if m_health    Health::null && _health    Health::null 
	 
		damage_system   remove_id id    
		m_health   _health 
	 

	release m_health  

	if m_health    Health::null && _health    Health::null 
	 
		m_health   _health 
		damage_system   add_id id    
	 
	else
		m_health   _health 
 

void Entity::set_visuals Visuals* _visuals 
 
	if m_visuals    Visuals::null && _visuals    Visuals::null 
		rendering_system   remove_id id    

	release m_visuals  

	if m_visuals    Visuals::null && _visuals    Visuals::null 
	 
		m_visuals   _visuals 
		rendering_system   add_id id    
	 
	else
		m_visuals   _visuals 
 

 * resource_system h
 *



class ResourceSystem
 
public:
    ResourceSystem     

    ~ResourceSystem  
     
        clear   
     

    ResourceSystem const ResourceSystem&    delete 
    ResourceSystem ResourceSystem&& rhs    default 

    ResourceSystem& operator  const ResourceSystem&    delete 
    ResourceSystem& operator  ResourceSystem&& rhs 
     
    	clear   
    	m_fonts   std::move rhs m_fonts  
    	m_procedures   std::move rhs m_procedures  
    	m_spritesheets   std::move rhs m_spritesheets  
    	m_textures   std::move rhs m_textures  

    	return *this 
     

    TextureID last_texture_id   const
     
        return m_textures size  -1 
     

    SpritesheetID last_spritesheet_id   const
     
        return m_spritesheets size  -1 
     

    ProcedureID last_procedure_id   const
     
        return m_procedures size  -1 
     

    FontID last_font_id   const
     
    	return m_fonts size  -1 
     

    void addNewTextureFromFile const std::string& file  SDL_Renderer* renderer 
     
        m_textures emplace_back   
        m_textures back   load_from_file file  renderer  
     

    void addNewTextureFromString const std::string& text  FontID font_id  uint8_t r  uint8_t g  uint8_t b  SDL_Renderer* renderer 
     
    	if font_id < m_fonts size   
    	 
    		m_textures emplace_back   
    		m_textures back   load_from_string text  m_fonts[font_id]  r  g  b  renderer  
    	 
    	else
    	 
    	 
     

    void addNewSpritesheet int idle_start  int idle_size
                           int walk_start  int walk_size
                           int jump_start  int jump_size
                           int fall_start  int fall_size
                           int attack_start  int attack_size
                           int hit_start  int hit_size
                           int dead_start  int dead_size
                           double scale_factor
                           
     
        m_spritesheets push_back Spritesheet idle_start  idle_size
											     walk_start  walk_size
											     jump_start  jump_size
											     fall_start  fall_size
											     attack_start  attack_size
											     hit_start  hit_size
											     dead_start  dead_size
											     scale_factor
												 
                                  
     

    void addNewSprite SpritesheetID spritesheet_id  const Sprite& sprite 
     
        if spritesheet_id < m_spritesheets size   
         
        	m_spritesheets[spritesheet_id] add_sprite sprite texture_id  sprite clip x  sprite clip y  sprite clip w  sprite clip h  
         
        else
         
         
     

    void addNewProcedure  
     
        m_procedures emplace_back   
     

    void addNewFont const std::string& font_file  int size 
     
    	m_fonts push_back Font font_file  size   
     

    const std::vector<Texture>& textures   const
     
        return m_textures 
     

    optional_ref<Texture> texture TextureID tex_id 
     
        if tex_id < m_textures size   
            return optional_ref<Texture> m_textures[tex_id]  
        else
        	return optional_ref<Texture>   
     

    const std::vector<Spritesheet>& spritesheets   const
     
        return m_spritesheets 
     

    optional_ref<Spritesheet> spritesheet SpritesheetID spr_id 
     
        if spr_id < m_spritesheets size   
        	return optional_ref<Spritesheet> m_spritesheets[spr_id]  
        else
        	return optional_ref<Spritesheet>   
     

    const std::vector<ProcedureCommand>& procedures   const
     
        return m_procedures 
     

    optional_ref<ProcedureCommand> procedure ProcedureID id 
     
        if id < m_procedures size   
        	return optional_ref<ProcedureCommand> m_procedures[id]  
		else
			return optional_ref<ProcedureCommand>   
     

    optional_ref<Font> font FontID id 
     
    	if id < m_fonts size   
    		return optional_ref<Font> m_fonts[id]  
    	else
    		return optional_ref<Font>   
     

    void clear_textures  
     
        m_textures clear   
     

    void clear_spritesheets  
     
        m_spritesheets clear   
     

    void clear_procedures  
     
        m_procedures clear   
     

    void clear_fonts  
     
        m_fonts clear   
     

    void clear  
     
        clear_textures   
        clear_spritesheets   
        clear_procedures   
        clear_fonts   
     

private:
    std::vector<Texture> m_textures 
    std::vector<Spritesheet> m_spritesheets 
    std::vector<ProcedureCommand> m_procedures 
    std::vector<Font> m_fonts 
  





 * collision_system h
 *



class CollisionSystem : public SystemBase
 
public:
    void update const Time time_diff  
    std::unordered_map<EntityID  bool> entities_last_triggered_reset   
  

 * damage_system h
 *



class DamageSystem : public SystemBase
 
public:
    void update const Time time_diff  
  

 * control_system h
 *



class ControlSystem : public SystemBase
 
public:
    void update const Time time_diff  
  


 * rendering_system h
 *



class RenderingSystem
 
public:
	RenderingSystem     
    void add_id EntityID entity  
    void remove_id EntityID entity  
    void clear  
     
    	for int layer   0  layer < Visuals::NUM_OF_LAYERS    layer 
    		entities[layer] clear   
     

    void set_entity_layer EntityID entity  Visuals::VisualLayer layer  
    void render_entities const Time time_diff  const bool paused  SDL_Renderer* renderer  const 

protected:
    std::list<EntityID> entities[Visuals::NUM_OF_LAYERS] 
  

 * system_base h
 *



class SystemBase
 
public:
    void add_id const EntityID entity 
     
    	auto it   std::find_if cbegin entities   cend entities   [entity] EntityID id   return id    entity     
    	if it    cend entities  
    		entities push_back entity  
     

    void remove_id const EntityID entity 
     
    	auto it   std::find_if cbegin entities   cend entities   [entity] EntityID id   return id    entity     
    	if it    cend entities  
			entities erase it  
     

    void clear  
     
        entities clear   
     

protected:
    std::list<EntityID> entities 
  

 * entity_system h
 *



class EntitySystem
 
public:
	EntitySystem   : m_entities  
				     m_entities_to_remove  
				     m_free_entities  
				     m_last_accessed_entities  
				     m_head_of_last_accessed_entities 0 
				     
    ~EntitySystem  
     
    	clear   
     

    EntitySystem const EntitySystem&    delete 
    EntitySystem EntitySystem&& rhs  : m_entities std::move rhs m_entities  
    								   m_entities_to_remove std::move rhs m_entities_to_remove  
    								   m_free_entities std::move rhs m_free_entities  
    								   m_last_accessed_entities std::move rhs m_last_accessed_entities  
    								   m_head_of_last_accessed_entities std::move rhs m_head_of_last_accessed_entities  
      

    EntitySystem& operator  const EntitySystem&    delete 
    EntitySystem& operator  EntitySystem&& rhs 
     
    	clear   
    	m_entities   std::move rhs m_entities  
    	m_entities_to_remove   std::move rhs m_entities_to_remove  
    	m_free_entities   std::move rhs m_free_entities  

    	return *this 
     

    Entity& add_new_entity   
    void remove_entity EntityID id 
     
    	m_entities_to_remove push_back id  
     


    optional_ref<Entity> entity EntityID id 
     
    	if id >  0 && id < int m_entities size    
    		return optional_ref<Entity> m_entities[id]  
    	else
    		return optional_ref<Entity>   
     

    void clear  
     
        m_entities clear   
        m_entities_to_remove clear   
        m_free_entities clear   
     

    void clean_removed_entites   

    void add_accessed_entity EntityID id 
     
    	m_head_of_last_accessed_entities    m_head_of_last_accessed_entities 1  m_last_accessed_entities size   
    	m_last_accessed_entities[m_head_of_last_accessed_entities]   id 
     

    optional_ref<Entity> previous_entity  
	 
    	if previous_entity_id   < m_entities size   
    		return optional_ref<Entity> m_entities[previous_entity_id  ]  
    	else
    		return optional_ref<Entity>   
	 

    EntityID previous_entity_id   const
     
    	return m_last_accessed_entities[m_head_of_last_accessed_entities] 
     

    EntityID previous_entity_id unsigned int n  const
       TODO make sure n < size
		return m_last_accessed_entities[ m_head_of_last_accessed_entities m_last_accessed_entities size  -n  m_last_accessed_entities size  ] 
     

private:
    std::vector<Entity> m_entities 
    std::list<EntityID> m_entities_to_remove 
    std::list<EntityID> m_free_entities 
    std::array<EntityID  10> m_last_accessed_entities 
    unsigned int m_head_of_last_accessed_entities 
  

 * movement_system h
 *



class MovementSystem : public SystemBase
 
public:
    constexpr static double GRAVITY_ACCEL   -0 00980665    always  IRL  9 80665m s 2   0 00980665mm ms 2 

    void update const Time time_delta  
  

 * sprite h
 *



struct Sprite
 
    Sprite TextureID texture_id  const SDL_Rect& rect 
    : texture_id texture_id 
      clip rect 
      

    Sprite   : Sprite 0   0  0  0  0     


    TextureID texture_id 
    SDL_Rect clip 
  

 * utilities h
 *



constexpr double absolute_or_scaled double val  double scale 
 
	return val* is_normalized val * scale-1  1  
 

inline EntityID resolved_entity EntityID in_entity_id 
 
	return  in_entity_id >  0 *in_entity_id    in_entity_id < 0 *entity_system   previous_entity_id 1-in_entity_id  
 

 * spritesheet h
 *



class Spritesheet
 
public:
    Spritesheet uint8_t idle_start
			    uint8_t idle_size
			    uint8_t walk_start
			    uint8_t walk_size
			    uint8_t jump_start
			    uint8_t jump_size
			    uint8_t fall_start
			    uint8_t fall_size
			    uint8_t attack_start
			    uint8_t attack_size
			    uint8_t hit_start
			    uint8_t hit_size
			    uint8_t dead_start
			    uint8_t dead_size
			    double scale_factor
			   
	: m_sprites  
      m_idle_sprite_start idle_start 
      m_idle_sprite_size idle_size 
      m_walk_sprite_start walk_start 
      m_walk_sprite_size walk_size 
      m_jump_sprite_start jump_start 
      m_jump_sprite_size jump_size 
      m_fall_sprite_start fall_start 
      m_fall_sprite_size fall_size 
	  m_attack_sprite_start attack_start 
	  m_attack_sprite_size attack_size 
	  m_hit_sprite_start hit_start 
	  m_hit_sprite_size hit_size 
      m_dead_sprite_start dead_start 
      m_dead_sprite_size dead_size 
      m_scale_factor scale_factor 
      

    Spritesheet  
    : Spritesheet 0  0  0  0  0  0  0  0  0  0  0  0  0  0  1 0 
      

    void add_sprite TextureID tex_index  int x  int y  int w  int h  

    const optional_ref<const Sprite> sprite unsigned int index  const
     
    	if index < m_sprites size   
            return optional_ref<const Sprite> m_sprites[index]  
    	else
    		return optional_ref<const Sprite>   
     

    optional_ref<Sprite> sprite unsigned int index 
     
    	if index < m_sprites size   
            return optional_ref<Sprite> m_sprites[index]  
    	else
    		return optional_ref<Sprite>   
     

    void set_scale_factor double scale 
     
        m_scale_factor   scale 
     

    double scale_factor   const   return m_scale_factor   

    void set_idle_sprite_start unsigned int val    m_idle_sprite_start   val   
    void set_idle_sprite_size  unsigned int val    m_idle_sprite_size   val   
    void set_walk_sprite_start unsigned int val    m_walk_sprite_start   val   
    void set_walk_sprite_size  unsigned int val    m_walk_sprite_size   val   
    void set_jump_sprite_start unsigned int val    m_jump_sprite_start   val   
    void set_jump_sprite_size  unsigned int val    m_jump_sprite_size   val   
    void set_fall_sprite_start unsigned int val    m_fall_sprite_start   val   
    void set_fall_sprite_size  unsigned int val    m_fall_sprite_size   val   
    void set_attack_sprite_start unsigned int val   m_attack_sprite_start   val   
    void set_attack_sprite_size  unsigned int val   m_attack_sprite_size   val   
    void set_hit_sprite_start unsigned int val    m_hit_sprite_start   val   
    void set_hit_sprite_size  unsigned int val    m_hit_sprite_size   val   
    void set_dead_sprite_start unsigned int val    m_dead_sprite_start   val   
    void set_dead_sprite_size  unsigned int val    m_dead_sprite_size   val   

    unsigned int idle_sprite_start  const   return m_idle_sprite_start   
    unsigned int idle_sprite_size   const   return m_idle_sprite_size   
    unsigned int walk_sprite_start  const   return m_walk_sprite_start   
    unsigned int walk_sprite_size   const   return m_walk_sprite_size   
    unsigned int jump_sprite_start  const   return m_jump_sprite_start   
    unsigned int jump_sprite_size   const   return m_jump_sprite_size   
    unsigned int fall_sprite_start  const   return m_fall_sprite_start   
    unsigned int fall_sprite_size   const   return m_fall_sprite_size   
    unsigned int attack_sprite_start  const  return m_attack_sprite_start   
    unsigned int attack_sprite_size   const  return m_attack_sprite_size   
    unsigned int hit_sprite_start  const   return m_hit_sprite_start   
    unsigned int hit_sprite_size   const   return m_hit_sprite_size   
    unsigned int dead_sprite_start  const   return m_dead_sprite_start   
    unsigned int dead_sprite_size   const   return m_dead_sprite_size   

private:
    std::vector<Sprite> m_sprites 

    unsigned int m_idle_sprite_start 
    unsigned int m_idle_sprite_size 
    unsigned int m_walk_sprite_start 
    unsigned int m_walk_sprite_size 
    unsigned int m_jump_sprite_start 
    unsigned int m_jump_sprite_size 
    unsigned int m_fall_sprite_start 
    unsigned int m_fall_sprite_size 
    unsigned int m_attack_sprite_start 
    unsigned int m_attack_sprite_size 
    unsigned int m_hit_sprite_start 
    unsigned int m_hit_sprite_size 
    unsigned int m_dead_sprite_start 
    unsigned int m_dead_sprite_size 
    double m_scale_factor 
  



 * font h
 *



class Font
 
public:
	Font const std::string& font_file  int size  : m_font nullptr 
	 
		set_font font_file  size  
	 

	Font   : m_font nullptr    

	~Font  
	 
		if m_font    nullptr 
			TTF_CloseFont m_font  
	 

	Font const Font&    delete 
	Font Font&& rhs  : m_font std::move rhs m_font     rhs m_font   nullptr   

	Font& operator  const Font&    delete 
	Font& operator  Font&& rhs 
	 
		if m_font    nullptr 
			TTF_CloseFont m_font  

		m_font   rhs m_font 
		rhs m_font   nullptr 

		return *this 
	 

	void set_font const std::string& font_file  int size 
	 
		if m_font 
			TTF_CloseFont m_font  

		m_font   TTF_OpenFont font_file c_str    size  
	    if m_font    nullptr 
	     
	    	std::cerr << "Failed to load " << font_file << " font: " << TTF_GetError   << std::endl 
	     
	 

	TTF_Font* font  
	 
		return m_font 
	 

private:
	TTF_Font *m_font 
  

 * optional_ref h
 *



template<typename T  typename Func>
auto operator  std::optional<T> opt  Func f    std::optional<decltype f *opt  >
 
    if opt 
        return std::optional f *opt   
    else
        return std::nullopt 
 

template<typename T  typename Func>
std::optional<T> operator- std::optional<T> opt  Func f 
 
    if  opt  f   

    return opt 
 

template<typename T>
class optional_ref
 
    public:
    optional_ref   : m_valid false   m_value nullValue    
    optional_ref T& ref  : m_valid true   m_value ref    
    optional_ref T&& ref  : m_valid true   m_value ref    
    optional_ref const optional_ref& rhs  : m_valid rhs m_valid   m_value rhs m_value    
    optional_ref optional_ref&& rhs  : m_valid std::move rhs m_valid    m_value rhs m_value    
    ~optional_ref     default 

    optional_ref& operator  const optional_ref& rhs    delete    undefined for now so don't use
        if m_valid && rhs m_valid 
            m_value   rhs m_value 

        return *this 

    optional_ref& operator  optional_ref&& rhs    delete    undefined for now so don't use
    	if m_valid && rhs m_valid 
    		m_value   rhs m_value 

    	return *this 

    T& operator*     return m_value   
    const T& operator*   const   return m_value   

    T* operator      return &m_value   
    const T* operator    const   return &m_value   

    template<typename Func>
    auto operator  Func f    std::optional<decltype f **this  >
     
        if m_valid 
        	return std::optional f m_value   
        else
          return std::nullopt 
     
    template<typename Func>
    optional_ref& operator  Func f 
     
        if m_valid  f m_value  

        return *this 
     

    template<typename Func>
    optional_ref& operator- Func f 
     
        if  m_valid  f   

        return *this 
     

    operator bool   const
     
        return m_valid 
     

    private:
    bool m_valid 
    T&  m_value 

    static T nullValue 
  

template<typename T>
T optional_ref<T>::nullValue    

 * math_ext h
 *



template <typename T>
constexpr int sign T val 
 
    return  T 0  < val  -  val < T 0   
 

template <typename T>
constexpr T abs T val 
 
    return T val * sign val   
 

template <typename T>
constexpr T max T val0  T val1 
 
    return T  val0 val1  2 0   abs val0-val1  2 0  
 

template <typename T>
constexpr T min T val0  T val1 
 
    return T  val0 val1  2 0 - abs val0-val1  2 0  
 

template <typename T>
constexpr T clip T val0  T val1  T val2 
 
    T min_val   min val1  val2  
    T max_val   min_val   abs val1-val2  
    return min max val0  min_val   max_val  
 

constexpr double lines_cross const double x0  const double y0  const double w0  const double h0  const double x1  const double y1  const double w1  const double h1 
 
	const double d    w1*h0 - h1*w0  

    if d    0  return -1 

    const double t1     x0-x1 *h0 -  y0-y1 *w0    d 
    const double t0     x0-x1 *h1 -  y0-y1 *w1    d 

    if t0 >  0 && t1 >  0 && t1 <  1 0 
        return t0 
    else
        return -1 
 

constexpr bool objects_collide const double x0  const double y0  const double w0  const double h0  const double x1  const double y1  const double w1  const double h1 
 
	const double x3   x1   w1 
	const double y3   y1   h1 
	const double sx   x0   w0   w1 
	const double sy   y0   h0   h1 

    return x3 > x0 && x3 < sx && y3 > y0 && y3 < sy 
 

constexpr bool is_integer const double val 
 
	return int val     val 
 

constexpr bool is_negative_zero const double val 
 
	return val    0 && std::signbit val  
 

constexpr bool is_normalized const double val 
 
	return  val >  -1 0  &&  val <  1 0  
 

 * full_interaction h
 *



class FullInteraction : public Interaction
 
public:
	FullInteraction int32_t group_vec  int8_t trigger_group  ProcedureID proc_id_self  ProcedureID on_exit_proc_id_self  ProcedureID proc_id_other 
	: m_group_vec group_vec 
	  m_trigger_group trigger_group 
	  m_triggered false 
	  m_proc_id_self proc_id_self 
	  m_on_exit_proc_id_self on_exit_proc_id_self 
	  m_proc_id_other proc_id_other 
	  

	FullInteraction int8_t trigger_group  ProcedureID proc_id_self  ProcedureID on_exit_proc_id_self  ProcedureID proc_id_other 
	: FullInteraction 0  trigger_group  proc_id_self  on_exit_proc_id_self  proc_id_other 
	  

	FullInteraction   : FullInteraction 0  -1  -1  -1    

	bool is_in_group int group_id  const   return  m_group_vec >> group_id  2   
	void set_group int group_id  bool val 
	 
		int32_t mask   ~ int32_t 1 << group_id   
		m_group_vec    m_group_vec & mask     val << group_id  
	 
	void clear_groups     m_group_vec   0   

	int8_t trigger_group   const   return m_trigger_group   
	bool triggered   const   return m_triggered   
	ProcedureID proc_id_self   const   return m_proc_id_self   
	ProcedureID proc_id_other   const   return m_proc_id_other   
	ProcedureID on_exit_proc_id_self   const   return m_on_exit_proc_id_self   

	void set_trigger_group int8_t group    m_trigger_group   group   
	void set_triggered bool triggered    m_triggered   triggered   
	void set_proc_id_self ProcedureID proc_id    m_proc_id_self   proc_id   
	void set_proc_id_other ProcedureID proc_id    m_proc_id_other   proc_id   
	void set_on_exit_proc_id_self ProcedureID proc_id    m_on_exit_proc_id_self   proc_id   

private:
	int32_t m_group_vec 
	int8_t m_trigger_group 
	bool m_triggered 
	ProcedureID m_proc_id_self  m_on_exit_proc_id_self  m_proc_id_other 

  

 * collision h
 *



class Collision
 
public:
    enum SurfaceType  AIR   0  GROUND   1  
    enum CollisionState  TRANSPARENT   0  MOVEABLE   1  SOLID   2  
    virtual ~Collision     

    virtual CollisionState state   const   0 
    virtual SurfaceType standing_on   const   0 
    virtual double on_collision_damage   const   0 

    virtual void set_state CollisionState val    0 
    virtual void set_standing_on SurfaceType surface    0 
    virtual void set_collision_damage double    0 

    static Collision* null 
  

 * position h
 *


class Position
 
public:
    virtual ~Position     
    virtual double x   const   0 
    virtual double y   const   0 
    virtual double w   const   0 
    virtual double h   const   0 

    virtual void set_x double val    0 
    virtual void set_y double val    0 
    virtual void set_w double val    0 
    virtual void set_h double val    0 

    virtual void mod_x double val    0 
    virtual void mod_y double val    0 
    virtual void mod_w double val    0 
    virtual void mod_h double val    0 

    static Position* null 
  

 * null_control h
 *



class NullControl : public Control
 
public:
    bool decision_jump   const   return false   
    bool decision_duck   const   return false   
    bool decision_attack   const   return false   
    int8_t decision_walk   const   return 0   
    ProcedureID attack_proc_id   const   return -1   
    LookDir look_dir   const   return RIGHT   

    void set_decision_jump bool val    
    void set_decision_duck bool val    
    void set_decision_attack bool val    
    void set_decision_walk int8_t val    
    void set_attack_proc_id ProcedureID val    
    void set_look_dir LookDir val    

    void update_decisions Time time    
    void clear_decisions     
  

 * null_movement h
 *



class NullMovement : public Movement
 
public:
    void set_force_x double val    
    void set_force_y double val    
    void mod_force_x double val    
    void mod_force_y double val    
    void set_velocity_x double val    
    void set_velocity_y double val    
    void mod_velocity_x double val    
    void mod_velocity_y double val    
    void set_mass double val    
    void set_friction double val    
    void set_move_force double val    
    void set_jump_force double val    
    double fx   const   return 0   
    double fy   const   return 0   
    double vx   const   return 0   
    double vy   const   return 0   
    double mass   const   return 0   
    double friction   const   return 0   
    double move_force   const   return 0   
    double jump_force   const   return 0   
    bool gravity_affected   const   return false   
    void set_gravity_affected bool val    
  

 * chase_ai_control h
 *



class ChaseAIControl : public Control
 
public:
	ChaseAIControl EntityID self_id  EntityID target_id  ProcedureID attack_proc_id  double attack_cooldown  double attack_range 
	: m_walk_dir 0 
	  m_attack false 
	  m_attack_proc_id attack_proc_id 
	  m_attack_cooldown attack_cooldown 
	  m_current_attack_cooldown 0 
	  m_self_id self_id 
	  m_target_id target_id 
	  m_look_dir RIGHT 
	  m_attack_range attack_range 
	  

    bool decision_jump   const   return false   
    bool decision_duck   const   return false   
    bool decision_attack   const   return m_attack   
    int8_t decision_walk   const   return m_walk_dir   
    ProcedureID attack_proc_id   const   return m_attack_proc_id   
    LookDir look_dir   const   return m_look_dir   

    void set_decision_jump bool val    
    void set_decision_duck bool val    
    void set_decision_attack bool val    m_attack   val   
    void set_decision_walk int8_t val    m_walk_dir   val   
    void set_attack_proc_id ProcedureID val    m_attack_proc_id   val   
    void set_look_dir LookDir val    m_look_dir   val   

    void update_decisions Time time_diff  
    void clear_decisions  
     
        m_walk_dir   0 
        m_attack   false 
     

private:
    int8_t m_walk_dir 
    bool m_attack 
    ProcedureID m_attack_proc_id 
    int m_attack_cooldown 
    int m_current_attack_cooldown 
    EntityID m_self_id  m_target_id 
    LookDir m_look_dir 
    double m_attack_range 
  


 * control h
 *



class Control
 
public:
    enum LookDir  RIGHT   0  LEFT   1  
    virtual ~Control     

    virtual bool decision_jump   const   0 
    virtual bool decision_duck   const   0 
    virtual bool decision_attack   const   0 
    virtual int8_t decision_walk   const   0 
    virtual ProcedureID attack_proc_id   const   0 
    virtual LookDir look_dir   const   0 

    virtual void set_decision_jump bool val    0 
    virtual void set_decision_duck bool val    0 
    virtual void set_decision_attack bool val    0 
    virtual void set_decision_walk int8_t val    0 
    virtual void set_attack_proc_id ProcedureID val    0 
    virtual void set_look_dir LookDir val    0 

    virtual void update_decisions Time time    0 
    virtual void clear_decisions     0 

    static Control* null 
  


 * interaction h
 *



class Interaction
 
public:
	static const int NUM_OF_GROUPS   32 

	virtual ~Interaction     

	virtual bool is_in_group int group_id  const   0 
	virtual int8_t trigger_group   const   0 
	virtual bool triggered   const   0 
	virtual ProcedureID proc_id_self   const   0 
	virtual ProcedureID proc_id_other   const   0 
	virtual ProcedureID on_exit_proc_id_self   const   0 

	virtual void clear_groups     0 
	virtual void set_group int group_id  bool val    0 
	virtual void set_trigger_group int8_t group    0 
	virtual void set_triggered bool triggered    0 
	virtual void set_proc_id_self ProcedureID proc_id    0 
	virtual void set_proc_id_other ProcedureID proc_id    0 
	virtual void set_on_exit_proc_id_self ProcedureID proc_id    0 

	static Interaction* null 
  

 * static_visuals h
 *



class StaticVisuals : public Visuals
 
public:
	StaticVisuals SpritesheetID spr_id  int sprite 
	: m_spr_id spr_id 
	  m_sprite sprite 
	  m_layer FAR_BACKGROUND 
	  

	StaticVisuals   : StaticVisuals -1  0    
    RenderStates state   const   return IDLE   
    void set_new_state RenderStates new_state    
    void advance_animation Time time_diff    
    uint8_t animation_sprite uint16_t rx  uint16_t ry  const   return m_sprite   
    bool animation_count_max   const   return true   
    SpritesheetID spritesheet_id     return m_spr_id   
    void set_spritesheet_id SpritesheetID spr_id    m_spr_id   spr_id   
    uint16_t repeat_x   const   return 1   
    virtual uint16_t repeat_y   const   return 1   
    virtual void set_repeat_x uint16_t val    
    virtual void set_repeat_y uint16_t val    
    VisualLayer layer   const   return m_layer   
    void set_layer VisualLayer val    m_layer   val   

private:
    SpritesheetID m_spr_id 
    uint16_t m_sprite 
    VisualLayer m_layer 
  

 * guide_control h
 *



class GuideControl : public Control
 
public:
	GuideControl EntityID self_id  EntityID target_id  ProcedureID attack_proc_id  double attack_cooldown  double attack_range 
	: m_walk_dir 0 
	  m_jump false 
	  m_duck false 
	  m_attack false 
	  m_attack_proc_id attack_proc_id 
	  m_attack_cooldown attack_cooldown 
	  m_current_attack_cooldown 0 
	  m_self_id self_id 
	  m_target_id target_id 
	  m_look_dir RIGHT 
	  m_attack_range attack_range 
	  

    bool decision_jump   const   return m_jump   
    bool decision_duck   const   return m_duck   
    bool decision_attack   const   return m_attack   
    int8_t decision_walk   const   return m_walk_dir   
    ProcedureID attack_proc_id   const   return m_attack_proc_id   
    LookDir look_dir   const   return m_look_dir   

    void set_decision_jump bool val    m_jump   val   
    void set_decision_duck bool val    m_duck   val   
    void set_decision_attack bool val    m_attack   val   
    void set_decision_walk int8_t val    m_walk_dir   val   
    void set_attack_proc_id ProcedureID val    m_attack_proc_id   val   
    void set_look_dir LookDir val    m_look_dir   val   

    void update_decisions Time time_diff  
    void clear_decisions  
     
        m_walk_dir   0 
        m_attack   false 
        m_jump   false 
        m_duck   false 
     

private:
    int8_t m_walk_dir 
    bool m_jump 
    bool m_duck 
    bool m_attack 
    ProcedureID m_attack_proc_id 
    int m_attack_cooldown 
    int m_current_attack_cooldown 
    EntityID m_self_id  m_target_id 
    LookDir m_look_dir 
    double m_attack_range 
  



 * tiled_visuals h
 *



class TiledVisuals : public Visuals
 
public:
    TiledVisuals SpritesheetID spr_id  uint16_t repeat_x  uint16_t repeat_y 
    : m_spritesheet_id spr_id 
      m_repeat_x repeat_x 
      m_repeat_y repeat_y 
      m_layer ACTION 
      

    TiledVisuals   : TiledVisuals -1  0  0    
    ~TiledVisuals     

    RenderStates state   const   return IDLE   
    void set_new_state RenderStates new_state    
    void advance_animation Time time_diff    
    bool animation_count_max   const   return 0   

    uint8_t animation_sprite uint16_t rx  uint16_t ry  const
     
    	return  rx > 0  *  1    rx   repeat_x  -1      3*  ry > 0  *  1    ry   repeat_y  -1     
     

    SpritesheetID spritesheet_id     return m_spritesheet_id   
    void set_spritesheet_id SpritesheetID spr_id    m_spritesheet_id   spr_id   

    uint16_t repeat_x   const   return m_repeat_x   
    uint16_t repeat_y   const   return m_repeat_y   
    void set_repeat_x uint16_t val    m_repeat_x   val   
    void set_repeat_y uint16_t val    m_repeat_y   val   
    VisualLayer layer   const   return m_layer   
    void set_layer VisualLayer val    m_layer   val   

private:
    SpritesheetID m_spritesheet_id 
    uint16_t m_repeat_x  m_repeat_y 
    VisualLayer m_layer 
  

 * constant_control h
 *



class ConstantControl : public Control
 
public:
	ConstantControl int8_t move_decision  bool jump_decision  bool duck_decision  LookDir look_dir 
	: m_move_decision move_decision 
	  m_jump_decision jump_decision 
	  m_duck_decision duck_decision 
	  m_look_dir look_dir 
	  

    bool decision_jump   const   return m_jump_decision   
    bool decision_duck   const   return m_duck_decision   
    bool decision_attack   const   return false   
    int8_t decision_walk   const   return m_move_decision   
    ProcedureID attack_proc_id   const   return -1   
    LookDir look_dir   const   return m_look_dir   

    void set_decision_jump bool val    m_jump_decision   val   
    void set_decision_duck bool val    m_duck_decision   val   
    void set_decision_attack bool val    
    void set_decision_walk int8_t val    m_move_decision   val   
    void set_attack_proc_id ProcedureID val    
    void set_look_dir LookDir val    m_look_dir   val   

    void update_decisions Time time    
    void clear_decisions  
     
    	m_move_decision   0 
    	m_jump_decision   false 
    	m_duck_decision   false 
     

private:
    int8_t m_move_decision 
    bool m_jump_decision  m_duck_decision 
    LookDir m_look_dir 
  

 * menu_item_visuals h
 *



class MenuItemVisuals : public Visuals
 
public:
	MenuItemVisuals SpritesheetID spr_id  EntityID self_id 
	: m_spr_id spr_id 
	  m_self_id self_id 
	  

	RenderStates state   const   return IDLE   
    void set_new_state RenderStates new_state    
    void advance_animation int32_t time_diff    
    uint8_t animation_sprite uint16_t rx  uint16_t ry  const 
    bool animation_count_max   const   return true   
    SpritesheetID spritesheet_id     return m_spr_id   
    void set_spritesheet_id SpritesheetID spr_id    m_spr_id   spr_id   
    uint16_t repeat_x   const   return 1   
    uint16_t repeat_y   const   return 1   
    void set_repeat_x uint16_t val    
    void set_repeat_y uint16_t val    
    VisualLayer layer   const   return FOREGROUND   
    void set_layer VisualLayer val    

private:
    SpritesheetID m_spr_id 
    EntityID m_self_id 
  

 * timed_health h
 *



class TimedHealth : public Health
 
public:
    TimedHealth double ttl  ProcedureID proc_id 
	: m_time_to_live ttl 
	  m_max_ttl ttl 
	  m_ttl_change 0 0 
	  m_proc_id proc_id 
	  

    void set_max_hp double hp    m_max_ttl   hp   
    void set_hp double hp    m_time_to_live   hp   
    void set_hp_change double hp_change    m_ttl_change   hp_change   
    void mod_hp_change double hp_change    m_ttl_change    hp_change   
    void update_health double time_diff 
     
    	m_time_to_live   clip m_time_to_live m_ttl_change-time_diff  0 0  m_max_ttl  
    	m_ttl_change   0 
     

    double hp   const   return m_time_to_live   
    double max_hp   const   return m_max_ttl   
    bool alive   const   return m_time_to_live > 0   
    ProcedureID on_death_exec   const   return m_proc_id   
    void set_on_death_exec ProcedureID val    m_proc_id   val   
    bool stunned   const   return false   

private:
    double m_time_to_live 
    double m_max_ttl 
    double m_ttl_change 
    ProcedureID m_proc_id 
  

 * health h
 *



class Health
 
public:
    virtual ~Health     

    virtual double hp   const   0 
    virtual double max_hp   const   0 
    virtual bool alive   const   0 
    virtual ProcedureID on_death_exec   const   0 
    virtual bool stunned   const   0 

    virtual void set_max_hp double hp    0 
    virtual void set_hp double hp    0 
    virtual void set_hp_change double hp_change    0 
    virtual void set_on_death_exec ProcedureID proc_id    0 

    virtual void mod_hp_change double hp_change    0 

    virtual void update_health double time_diff    0 

    static Health* null 
  

 * null_position h
 *



class NullPosition : public Position
 
public:
    double x   const   return 0   
    double y   const   return 0   
    double w   const   return 0   
    double h   const   return 0   

    void set_x double val    
    void set_y double val    
    void set_w double val    
    void set_h double val    

    void mod_x double val    
    void mod_y double val    
    void mod_w double val    
    void mod_h double val    
  

 * null_interaction h
 *



class NullInteraction : public Interaction
 
	bool is_in_group int group_id  const   return false   
	void set_group int group_id  bool val    
	void clear_groups     
	int8_t trigger_group   const   return 0   
	bool triggered   const   return false   
	ProcedureID proc_id_self   const   return -1   
	ProcedureID proc_id_other   const   return -1   
	ProcedureID on_exit_proc_id_self   const   return -1   
	void set_trigger_group int8_t group    
	void set_triggered bool triggered    
	void set_proc_id_self ProcedureID proc_id    
	void set_proc_id_other ProcedureID proc_id    
	void set_on_exit_proc_id_self ProcedureID proc_id    
  

 * attached_health h
 *



class AttachedHealth : public Health
 
public:
	AttachedHealth EntityID attached_id  double offset_hp  double offset_max_hp 
	: m_attached_id attached_id 
	  m_offset_hp offset_hp 
	  m_offset_max_hp offset_max_hp 
	  

    void set_max_hp double hp    m_offset_max_hp   hp   
    void set_hp double hp    m_offset_hp   hp   
    void set_hp_change double hp_change    
    void mod_hp_change double hp_change    
    void update_health double time_diff    
    double hp   const 
    double max_hp   const 
    bool alive   const   return hp   > 0   
    ProcedureID on_death_exec   const   return -1   
    void set_on_death_exec ProcedureID proc_id    
    bool stunned   const   return false   

private:
    EntityID m_attached_id 
    double m_offset_hp  m_offset_max_hp 
  

 * null_collision h
 *



class NullCollision : public Collision
 
public:
    CollisionState state   const   return TRANSPARENT   
    void set_state CollisionState val    
    SurfaceType standing_on   const   return GROUND   
    void set_standing_on SurfaceType surface    
    double on_collision_damage   const   return 0   
    void set_collision_damage double    
  

 * visuals h
 *



class Visuals
 
public:
    enum RenderStates   IDLE  WALK  JUMP  FALL  ATTACK  HIT  DEAD  
    enum VisualLayer  FAR_BACKGROUND   0  CLOSE_BACKGROUND   1  ACTION   2  ACTION_FRONT   3  FOREGROUND   4  
    static constexpr int ANIMATION_DELAY_MS   50 
    static constexpr int NUM_OF_LAYERS   5 

    virtual ~Visuals     

    virtual RenderStates state   const   0 
    virtual uint8_t animation_sprite uint16_t rx  uint16_t ry  const   0 
    virtual SpritesheetID spritesheet_id     0 
    virtual bool animation_count_max   const   0 
    virtual uint16_t repeat_x   const   0 
    virtual uint16_t repeat_y   const   0 
    virtual VisualLayer layer   const   0 

    virtual void set_new_state RenderStates new_state    0 
    virtual void set_spritesheet_id SpritesheetID spr_id    0 
    virtual void set_repeat_x uint16_t val    0 
    virtual void set_repeat_y uint16_t val    0 
    virtual void set_layer VisualLayer val    0 

    virtual void advance_animation Time time_diff    0 

    static Visuals* null 
  

 * character_visuals h
 *



class CharacterVisuals : public Visuals
 
public:
    static const unsigned int ANIMATION_DELAY_MS   50 

    CharacterVisuals SpritesheetID spr_id 
    : m_current_state IDLE 
      m_animation_count 0 
      m_animation_time 0 
      m_spritesheet_id spr_id 
      m_layer ACTION 
      

    CharacterVisuals   : CharacterVisuals -1    
    ~CharacterVisuals     

    RenderStates state   const   return m_current_state   
    void set_new_state RenderStates new_state 
     
        m_current_state   new_state 
        m_animation_count   0 
        m_animation_time   0 
     

    void advance_animation Time time_diff 
     
        m_animation_time    time_diff 
        if m_animation_time >  ANIMATION_DELAY_MS 
         
            m_animation_time -  ANIMATION_DELAY_MS 
    		m_animation_count    m_animation_count 1  animation_state_size   
         
     

    bool animation_count_max   const
     
        return  m_animation_count    animation_state_size  -1  
     

    uint8_t animation_sprite uint16_t rx  uint16_t ry  const
     
        return m_animation_count   animation_state_offset   
     

    SpritesheetID spritesheet_id     return m_spritesheet_id   
    void set_spritesheet_id SpritesheetID spr_id    m_spritesheet_id   spr_id   

    uint16_t repeat_x   const   return 1   
    uint16_t repeat_y   const   return 1   
    void set_repeat_x uint16_t val    
    void set_repeat_y uint16_t val    
    VisualLayer layer   const   return m_layer   
    void set_layer VisualLayer val    m_layer   val   

private:
    uint8_t animation_state_offset   const 
    uint8_t animation_state_size   const 

    RenderStates m_current_state 
    unsigned int m_animation_count 
    double m_animation_time 
    SpritesheetID m_spritesheet_id 
    VisualLayer m_layer 
  

 * input_select_control h
 *



class InputSelectControl : public Control
 
public:
	InputSelectControl InputHandler* input  int select  int max  ProcedureID proc_id 
    : m_input input 
	  m_select select 
	  m_max max 
	  m_curr_selection 0 
      m_proc_id proc_id 
      

    InputSelectControl   : InputSelectControl nullptr  0  0  -1    

    bool decision_jump   const   return m_select    m_curr_selection   
    bool decision_duck   const   return false   
    bool decision_attack   const
     
    	return m_select    m_curr_selection && m_input select   
     

    int8_t decision_walk   const   return false   
    ProcedureID attack_proc_id   const   return m_proc_id   
    LookDir look_dir   const   return RIGHT   

    void set_decision_jump bool val    
    void set_decision_duck bool val    
    void set_decision_attack bool val    
    void set_decision_walk int8_t val    
    void set_attack_proc_id ProcedureID val    m_proc_id   val   
    void set_look_dir LookDir val    

    void update_decisions int32_t time_diff 
     
    	m_curr_selection    m_input down   - m_input up     m_max 
    	m_curr_selection    m_max 
     

    void clear_decisions     

private:
    InputHandler* m_input 
    int m_select  m_max  m_curr_selection 
    ProcedureID m_proc_id 
  

 * movement h
 *



class Movement
 
public:
    virtual ~Movement     

    virtual double fx   const   0 
    virtual double fy   const   0 
    virtual double vx   const   0 
    virtual double vy   const   0 
    virtual double mass   const   0 
    virtual double friction   const   0 
    virtual double move_force   const   0 
    virtual double jump_force   const   0 
    virtual bool gravity_affected   const   0 

    virtual void set_force_x double val    0 
    virtual void set_force_y double val    0 
    virtual void set_velocity_x double val    0 
    virtual void set_velocity_y double val    0 
    virtual void set_mass double val    0 
    virtual void set_friction double val    0 
    virtual void set_move_force double val    0 
    virtual void set_jump_force double val    0 
    virtual void set_gravity_affected bool val    0 

    virtual void mod_force_x double ax    0 
    virtual void mod_force_y double ay    0 
    virtual void mod_velocity_x double vx    0 
    virtual void mod_velocity_y double vy    0 

    static Movement* null 
  

 * basic_collision h
 *



class BasicCollision : public Collision
 
public:
    BasicCollision CollisionState state 
    : m_state state 
      m_standing_on AIR 
      

    BasicCollision   : BasicCollision TRANSPARENT    

    CollisionState state   const   return m_state   
    void set_state CollisionState val    m_state   val   
    SurfaceType standing_on   const   return m_standing_on   
    void set_standing_on SurfaceType surface    m_standing_on   surface   
    double on_collision_damage   const   return 0   
    void set_collision_damage double    

private:
    CollisionState m_state 
    SurfaceType m_standing_on 
  

 * attached_position h
 *



class AttachedPosition : public Position
 
public:
    AttachedPosition EntityID attached_id  double offset_x  double offset_y  double offset_w  double offset_h 
    : m_attached_id attached_id 
      m_offset_x offset_x 
      m_offset_y offset_y 
      m_offset_w offset_w 
      m_offset_h offset_h 
      

    AttachedPosition EntityID attached_id 
    : AttachedPosition attached_id  0  0  0  0    

    double x   const 
    double y   const 
    double w   const 
    double h   const 

    void set_x double val    
    void set_y double val    
    void set_w double val    
    void set_h double val    

    void mod_x double val    m_offset_x    val   
    void mod_y double val    m_offset_y    val   
    void mod_w double val    m_offset_w    val   
    void mod_h double val    m_offset_h    val   

private:
    EntityID m_attached_id 
    double m_offset_x  m_offset_y  m_offset_w  m_offset_h 
  


 * trigger_interaction h
 *



class TriggerInteraction : public Interaction
 
public:
	TriggerInteraction int8_t trigger_group  ProcedureID proc_id_self  ProcedureID proc_id_other  ProcedureID on_exit_proc_id_self 
	: m_trigger_group trigger_group 
	  m_triggered false 
	  m_proc_id_self proc_id_self 
	  m_proc_id_other proc_id_other 
	  m_on_exit_proc_id_self on_exit_proc_id_self 
	  

	TriggerInteraction   : TriggerInteraction 0  -1  -1  -1    

	bool is_in_group int group_id  const   return false   
	void set_group int group_id  bool val    
	void clear_groups     

	int8_t trigger_group   const   return m_trigger_group   
	bool triggered   const   return m_triggered   
	ProcedureID proc_id_self   const   return m_proc_id_self   
	ProcedureID proc_id_other   const   return m_proc_id_other   
	ProcedureID on_exit_proc_id_self   const   return m_on_exit_proc_id_self   

	void set_trigger_group int8_t group    m_trigger_group   group   
	void set_triggered bool triggered    m_triggered   triggered   
	void set_proc_id_self ProcedureID proc_id    m_proc_id_self   proc_id   
	void set_proc_id_other ProcedureID proc_id    m_proc_id_other   proc_id   
	void set_on_exit_proc_id_self ProcedureID proc_id    m_on_exit_proc_id_self   proc_id   

private:
	int8_t m_trigger_group 
	bool m_triggered 
	ProcedureID m_proc_id_self  m_proc_id_other  m_on_exit_proc_id_self 
  

 * instant_movement h
 *



class InstantMovement : public Movement
 
public:
	InstantMovement double mass  double friction  double move_force 
    : m_mass mass 
	  m_friction friction 
	  m_move_force move_force 
      m_fx 0 
      m_fy 0 
      

    InstantMovement   : InstantMovement 1  0  0    

    void set_force_x double fx    m_fx   fx   
    void set_force_y double fy    m_fy   fy   
    void mod_force_x double fx    m_fx    fx   
    void mod_force_y double fy    m_fy    fy   
    void set_velocity_x double vx    set_force_x vx    
    void set_velocity_y double vy    set_force_y vy    
    void mod_velocity_x double vx    mod_force_x vx    
    void mod_velocity_y double vy    mod_force_y vy    
    void set_mass double val    m_mass   val   
    void set_friction double val    m_friction   val   
    void set_move_force double val    m_move_force   val   
    void set_jump_force double val    

    double fx   const   return m_fx   
    double fy   const   return m_fy   
    double vx   const   return m_fx   
    double vy   const   return m_fy   
    double mass   const   return m_mass   
    double friction   const   return m_friction   
    double move_force   const   return m_move_force   
    double jump_force   const   return 0   

    bool gravity_affected   const   return false   
    void set_gravity_affected bool val    

private:
    double m_mass  m_friction  m_move_force  m_fx  m_fy 
  




 * damage_collision h
 *



class DamageCollision : public Collision
 
public:
    DamageCollision CollisionState state  double damage 
	: m_state state 
	  m_damage damage 
	  
    DamageCollision   : DamageCollision TRANSPARENT  0    

    CollisionState state   const   return m_state   
    void set_state CollisionState val    m_state   val   
    SurfaceType standing_on   const   return AIR   
    void set_standing_on SurfaceType surface    
    double on_collision_damage   const   return m_damage   
    void set_collision_damage double damage    m_damage   damage   

private:
    CollisionState m_state 
    double m_damage 
  

 * null_health h
 *



class NullHealth : public Health
 
public:
    void set_max_hp double hp    
    void set_hp double hp    
    void set_hp_change double hp_change    
    void mod_hp_change double hp_change    
    void update_health double time_diff    
    double hp   const   return 0   
    double max_hp   const   return 0   
    bool alive   const   return true   
    ProcedureID on_death_exec   const   return -1   
    void set_on_death_exec ProcedureID proc_id    
    bool stunned   const   return false   
  

 * null_visuals h
 *



class NullVisuals : public Visuals
 
public:
    RenderStates state   const   return IDLE   
    void set_new_state RenderStates new_state    
    void advance_animation Time time_diff    
    uint8_t animation_sprite uint16_t rx  uint16_t ry  const   return 0   
    bool animation_count_max   const   return true   
    SpritesheetID spritesheet_id     return 0   
    void set_spritesheet_id SpritesheetID spr_id    
    uint16_t repeat_x   const   return 0   
    uint16_t repeat_y   const   return 0   
    void set_repeat_x uint16_t val    
    void set_repeat_y uint16_t val    
    VisualLayer layer   const   return FAR_BACKGROUND   
    void set_layer VisualLayer val    
  

 * input_control h
 *



class InputControl : public Control
 
public:
    InputControl InputHandler* input  ProcedureID shoot_proc_id  double shoot_cooldown  EntityID self_id 
    : m_input input 
      m_walk_dir 0 
      m_jump false 
	  m_duck false 
      m_shoot false 
      m_shoot_proc_id shoot_proc_id 
      m_shoot_cooldown shoot_cooldown 
	  m_current_shoot_cooldown 0 
	  m_look_dir RIGHT 
	  m_self_id self_id 
      

    InputControl InputHandler* input  EntityID self_id  : InputControl input  -1  0  self_id    
    InputControl   : InputControl nullptr  0    

    bool decision_jump   const   return m_jump   
    bool decision_duck   const   return m_duck   
    bool decision_attack   const   return m_shoot   
    int8_t decision_walk   const   return m_walk_dir   
    ProcedureID attack_proc_id   const   return m_shoot_proc_id   
    LookDir look_dir   const   return m_look_dir   

    void set_decision_jump bool val    m_jump   val   
    void set_decision_duck bool val    m_duck   val   
    void set_decision_attack bool val    m_shoot   val   
    void set_decision_walk int8_t val    m_walk_dir   val   
    void set_attack_proc_id ProcedureID val    m_shoot_proc_id   val   
    void set_look_dir LookDir val    m_look_dir   val   

    void update_decisions Time time_diff  
    void clear_decisions  
     
        m_jump   false 
        m_duck   false 
        m_shoot   false 
        m_walk_dir   0 
     

private:
    InputHandler* m_input 
    int8_t m_walk_dir 
    bool m_jump 
    bool m_duck 
    bool m_shoot 
    ProcedureID m_shoot_proc_id 
    int m_shoot_cooldown 
    int m_current_shoot_cooldown 
    LookDir m_look_dir 
    EntityID m_self_id 
  


 * character_health h
 *



class CharacterHealth : public Health
 
public:
	const int STUN_TIME   100 
    CharacterHealth double hp  double max_hp 
	: m_max_hit_points max_hp 
	  m_hp_change 0 
	  m_stun_cnt 0 
	  set_hp hp    

    CharacterHealth double hp  : CharacterHealth hp  hp    
    CharacterHealth   : CharacterHealth 0    

    void set_max_hp double hp 
     
        m_max_hit_points   hp 
        m_hit_points   clip m_hit_points  0 0  m_max_hit_points  
     

    void set_hp double hp 
     
        m_hit_points   clip hp  0 0  m_max_hit_points  
     

    void set_hp_change double hp_change 
     
        m_hp_change   hp_change 
     

    void mod_hp_change double hp_change 
     
        m_hp_change    hp_change 
     

    void update_health double time_diff 
     
    	if m_hp_change < 0    hit
    		m_stun_cnt   STUN_TIME 
    	else
    		m_stun_cnt   max m_stun_cnt - time_diff  0 0  

        m_hit_points   clip m_hit_points   m_hp_change  0 0  m_max_hit_points  
        m_hp_change   0 
     

    double hp   const   return m_hit_points   
    double max_hp   const   return m_max_hit_points   
    bool alive   const   return m_hit_points > 0   
    ProcedureID on_death_exec   const   return -1   
    void set_on_death_exec ProcedureID proc_id    
    bool stunned   const   return m_stun_cnt > 0   

private:
    double m_hit_points  m_max_hit_points  m_hp_change 
	int m_stun_cnt 
  

 * full_movement h
 *



class FullMovement : public Movement
 
public:
    FullMovement double mass  double friction  double move_force  double jump_force  bool gravity_affected 
    : m_mass mass 
      m_friction friction 
      m_move_force move_force 
      m_jump_force jump_force 
      m_vx 0 
      m_vy 0 
      m_fx 0 
      m_fy 0 
      m_gravity_affected gravity_affected 
      

    FullMovement bool gravity_affected  : FullMovement 0  0  0  0  gravity_affected    
    FullMovement   : FullMovement false    

    void set_force_x double fx    m_fx   fx   
    void set_force_y double fy    m_fy   fy   
    void mod_force_x double fx    m_fx    fx   
    void mod_force_y double fy    m_fy    fy   
    void set_velocity_x double vx    m_vx   vx   
    void set_velocity_y double vy    m_vy   vy   
    void mod_velocity_x double vx    m_vx   m_vx vx   
    void mod_velocity_y double vy    m_vy   m_vy vy   
    void set_mass double val    m_mass   val   
    void set_friction double val    m_friction   val   
    void set_move_force double val    m_move_force   val   
    void set_jump_force double val    m_jump_force   val   

    double fx   const   return m_fx   
    double fy   const   return m_fy   
    double vx   const   return m_vx   
    double vy   const   return m_vy   
    double mass   const   return m_mass   
    double friction   const   return m_friction   
    double move_force   const   return m_move_force   
    double jump_force   const   return m_jump_force   

    bool gravity_affected   const   return m_gravity_affected   
    void set_gravity_affected bool val    m_gravity_affected   val   

private:
    double m_mass  m_friction  m_move_force  m_jump_force 
    double m_vx  m_vy  m_fx  m_fy 
    bool m_gravity_affected 
  

 * character_health_visuals h
 *



class CharacterHealthVisuals : public Visuals
 
public:
	CharacterHealthVisuals EntityID self_id  SpritesheetID spr_id  uint16_t repeat_x 
	: m_self_id self_id 
	  m_spr_id spr_id 
	  m_repeat_x repeat_x 
	  

	CharacterHealthVisuals   : CharacterHealthVisuals -1  -1  0    
    RenderStates state   const   return IDLE   
    void set_new_state RenderStates new_state    
    void advance_animation Time time_diff    
    uint8_t animation_sprite uint16_t rx  uint16_t ry  const 
    bool animation_count_max   const   return true   
    SpritesheetID spritesheet_id     return m_spr_id   
    void set_spritesheet_id SpritesheetID spr_id    m_spr_id   spr_id   
    uint16_t repeat_x   const   return m_repeat_x   
    virtual uint16_t repeat_y   const   return 1   
    virtual void set_repeat_x uint16_t val    m_repeat_x   val   
    virtual void set_repeat_y uint16_t val    
    VisualLayer layer   const   return CLOSE_BACKGROUND   
    void set_layer VisualLayer val    

private:
    EntityID m_self_id 
    SpritesheetID m_spr_id 
    uint16_t m_repeat_x 
  

 * absolute_position h
 *



class AbsolutePosition : public Position
 
public:
    AbsolutePosition double x  double y  double w  double h 
    : m_x x   m_y y   m_width w   m_height h    
    AbsolutePosition   : AbsolutePosition 0  0  0  0    

    double x   const   return m_x   
    double y   const   return m_y   
    double w   const   return m_width   
    double h   const   return m_height   

    void set_x double val    m_x   val   
    void set_y double val    m_y   val   
    void set_w double val    m_width   val   
    void set_h double val    m_height   val   

    void mod_x double val    m_x    val   
    void mod_y double val    m_y    val   
    void mod_w double val    m_width    val   
    void mod_h double val    m_height    val   

private:
    double m_x  m_y  m_width  m_height 
  

 * normal_interaction h
 *



class NormalInteraction : public Interaction
 
public:
	NormalInteraction int32_t group_vec 
	: m_group_vec group_vec 
	  

	NormalInteraction   : NormalInteraction 0    

	bool is_in_group int group_id  const   return  m_group_vec >> group_id  2   
	void set_group int group_id  bool val 
	 
		int32_t mask   ~ int32_t 1 << group_id   
		m_group_vec    m_group_vec & mask     val << group_id  
	 
	void clear_groups     m_group_vec   0   

	int8_t trigger_group   const   return 0   
	bool triggered   const   return false   
	ProcedureID proc_id_self   const   return -1   
	ProcedureID proc_id_other   const   return -1   
	ProcedureID on_exit_proc_id_self   const   return -1   

	void set_trigger_group int8_t group    
	void set_triggered bool triggered    
	void set_proc_id_self ProcedureID proc_id    
	void set_proc_id_other ProcedureID proc_id    
	void set_on_exit_proc_id_self ProcedureID proc_id    

private:
	int32_t m_group_vec 
  

 * sdl_window h
 *



class SdlWindow
 
public:
	SdlWindow   : m_window nullptr   m_renderer nullptr 
	  

	void init_video const uint16_t res_width
				    const uint16_t res_height
				    const bool fullscreen
				    const bool double_buffer
			  

	~SdlWindow   

	SdlWindow const SdlWindow&    delete 
	SdlWindow SdlWindow&& rhs  : m_window rhs m_window   m_renderer rhs m_renderer 
	 
		rhs m_window   nullptr 
		rhs m_renderer   nullptr 
	 

	SdlWindow& operator  const SdlWindow&    delete 
	SdlWindow& operator  SdlWindow&& rhs 
	 
		SDL_DestroyWindow m_window  
		SDL_DestroyRenderer m_renderer  

		m_window   rhs m_window 
		m_renderer   rhs m_renderer 

		rhs m_window   nullptr 
		rhs m_renderer   nullptr 

		return *this 
	 

	SDL_Renderer* renderer  
	 
		return m_renderer 
	 

private:
	SDL_Window* m_window 
	SDL_Renderer* m_renderer 
  



 * texture h
 *



class Texture
 
public:
    Texture   : m_texture nullptr    

    ~Texture  
     
        unload   
     

    Texture const Texture&    delete 
    Texture Texture&& rhs  : m_texture rhs m_texture 
     
    	rhs m_texture   nullptr 
     

    Texture& operator  const Texture&    delete 
    Texture& operator  Texture&& rhs  noexcept
     
    	unload   
    	m_texture   rhs m_texture 
    	rhs m_texture   nullptr 

    	return *this 
     

    Texture& load_from_file const std::string& file  SDL_Renderer* renderer 
     
        unload   
        SDL_Surface* surface   IMG_Load file c_str    

        if surface    nullptr 
         
            std::cerr << "Cannot load image " << file << "  Error: " << IMG_GetError   << std::endl 
         
        else
         
            SDL_SetHint SDL_HINT_RENDER_SCALE_QUALITY  "linear"  
            m_texture   SDL_CreateTextureFromSurface renderer  surface  
            if m_texture    nullptr 
             
                std::cerr << "Cannot create texture from " << file << "  Error: " << SDL_GetError   << std::endl 
             
            SDL_FreeSurface surface  
         
        return *this 
     

    Texture& load_from_string const std::string& text  Font& font  uint8_t r  uint8_t g  uint8_t b  SDL_Renderer* renderer 
     
        unload   
        SDL_Surface* surface   TTF_RenderText_Solid font font    text c_str     r  g  b   

        if surface    nullptr 
         
            std::cerr << "Cannot render string '" << text << "'  Error: " << TTF_GetError   << std::endl 
         
        else
         
            m_texture   SDL_CreateTextureFromSurface renderer  surface  
            if m_texture    nullptr 
             
                std::cerr << "Cannot create texture for string '" << text << "'  Error: " << SDL_GetError   << std::endl 
             
            SDL_FreeSurface surface  
         
        return *this 
     

    void unload   noexcept
     
        if m_texture    nullptr 
         
            SDL_DestroyTexture m_texture  
            m_texture   nullptr 
         
     

    SDL_Texture* texture  
     
        return m_texture 
     

private:
    SDL_Texture* m_texture 
  

 * input_handler h
 *



class InputHandler
 
public:
	InputHandler  
	: m_keypause SDLK_p 
	  m_keyjump SDLK_w 
	  m_keydown SDLK_s 
	  m_keyleft SDLK_a 
	  m_keyright SDLK_d 
	  m_keyshoot SDLK_e 
	  m_keyquit SDLK_F10 
	  m_keyselect SDLK_RETURN 
	  m_left_pressed false 
	  m_right_pressed false 
	  m_jump_pressed false 
	  m_duck_pressed false 
	  m_shoot_pressed false 
	  m_up_pressed false 
	  m_down_pressed false 
	  m_select_pressed false 
	  

    void process_input   
    bool jumping   const   return m_jump_pressed   
    bool ducking   const   return m_duck_pressed   
    bool shooting   const   return m_shoot_pressed   
    bool going_left   const   return m_left_pressed   
    bool going_right   const   return m_right_pressed   
    bool up   const   return m_up_pressed   
    bool down   const   return m_down_pressed   
    bool select   const   return m_select_pressed   

private:
    SDL_Keycode m_keypause  m_keyjump  m_keydown  m_keyleft  m_keyright  m_keyshoot  m_keyquit  m_keyselect 
    bool m_left_pressed  m_right_pressed  m_jump_pressed  m_duck_pressed  m_shoot_pressed  m_up_pressed  m_down_pressed  m_select_pressed 
    SDL_Event m_event 
  

 * types h
 *


using EntityID   int32_t 
using SpritesheetID   int32_t 
using TextureID   int32_t 
using ProcedureID   int32_t 
using SoundID   int32_t 
using FontID   int32_t 
using Time   int32_t 

 * entity h
 *



template <class T>
void release T*& t 
 
	if t    T::null 
	 
		delete t 
		t   T::null 
	 
 

class Entity
 
public:
    Entity EntityID id  
    Entity   : Entity -1    
    ~Entity  
     
    	clear   
     

    Entity const Entity&    delete 
    Entity Entity&& rhs  : m_id std::move rhs m_id  
    					   m_position std::move rhs m_position  
						   m_control std::move rhs m_control  
    					   m_movement std::move rhs m_movement  
						   m_collision std::move rhs m_collision  
						   m_interaction std::move rhs m_interaction  
						   m_health std::move rhs m_health  
						   m_visuals std::move rhs m_visuals  
     
    	rhs m_position   nullptr 
    	rhs m_control   nullptr 
    	rhs m_movement   nullptr 
    	rhs m_collision   nullptr 
    	rhs m_interaction   nullptr 
    	rhs m_health   nullptr 
    	rhs m_visuals   nullptr 
     

    Entity& operator  const Entity&    delete 
    Entity& operator  Entity&& rhs 
     
    	delete m_position 
    	delete m_control 
    	delete m_movement 
    	delete m_collision 
    	delete m_interaction 
    	delete m_health 
    	delete m_visuals 

    	m_id   std::move rhs m_id  
		m_position   std::move rhs m_position  
		m_control   std::move rhs m_control  
		m_movement   std::move rhs m_movement  
		m_collision   std::move rhs m_collision  
		m_interaction   std::move rhs m_interaction  
		m_health   std::move rhs m_health  
		m_visuals   std::move rhs m_visuals  

		rhs m_position   nullptr 
    	rhs m_control   nullptr 
    	rhs m_movement   nullptr 
    	rhs m_collision   nullptr 
    	rhs m_interaction   nullptr 
    	rhs m_health   nullptr 
    	rhs m_visuals   nullptr 

    	return *this 
     

    Position* position     return m_position   
    Control* control     return m_control   
    Movement* movement     return m_movement   
    Collision* collision     return m_collision   
    Interaction* interaction     return m_interaction   
    Health* health     return m_health   
    Visuals* visuals     return m_visuals   

    void set_position Position* _position  
    void set_control Control* _control  
    void set_movement Movement* _movement  
    void set_collision Collision* _collision  
    void set_interaction Interaction* _interaction  
    void set_health Health* _health  
    void set_visuals Visuals* _visuals  

    void set_id EntityID id 
      m_id   id   

    EntityID id   const   return m_id   

    void clear  
     
    	release m_position  
    	release m_control  
    	release m_movement  
    	release m_collision  
    	release m_interaction  
    	release m_health  
    	release m_visuals  
     

private:
    EntityID m_id 
    Position* m_position 
    Control* m_control 
    Movement* m_movement 
    Collision* m_collision 
    Interaction* m_interaction 
    Health* m_health 
    Visuals* m_visuals 
  


 * globals h
 *




InputHandler& input_handler   
CommandQueue& command_queue   
EntitySystem& entity_system   
ResourceSystem& resource_system   
ControlSystem& control_system   
MovementSystem& movement_system   
CollisionSystem& collision_system   
DamageSystem& damage_system   
RenderingSystem& rendering_system   

struct Globals
 
	Globals   : app_running true 
    		    app_needs_reload false 
    		    app_paused false 
    		    fullscreen false 
			    show_hitboxes false 
    		    resolution_x 640 
    		    resolution_y 480 
    		    access_spritesheet_id -1 
    		    access_procedure_id -1 
			    level_name "levels menu txt" 
			    

    bool app_running  app_needs_reload  app_paused  fullscreen  show_hitboxes 
    uint16_t resolution_x  resolution_y 
    SpritesheetID access_spritesheet_id 
    ProcedureID access_procedure_id 
    std::string level_name 
  

Globals& globals   

 * file_parser h
 *



class FileParser
 
public:
    FileParser std::string filename 
     
        open filename  
     

    FileParser   : FileParser ""    

    ~FileParser  
     
    	close   
     

    FileParser const FileParser&     delete 
    FileParser FileParser&& rhs 
     
    	m_file   std::move rhs m_file  
     

    FileParser& operator  const FileParser&     delete 
    FileParser& operator  FileParser&& rhs 
     
    	close   
    	m_file   std::move rhs m_file  
    	return *this 
     

    void open const std::string& filename 
     
        if filename length   > 0 
         
        	if m_file is_open   
        		close   

            m_file open filename  
            if m_file is_open      false 
             
                std::cerr << "File " << filename << " cannot be opened " << std::endl 
             
         
     

    void close  
     
    	m_file close   
     

    optional_ref<std::ifstream> read  
     
    	if m_file is_open   
    		return optional_ref<std::ifstream> m_file  
    	else
    		return optional_ref<std::ifstream>   
     

private:
    std::ifstream m_file 
  

 * command_queue h
 *



class CommandQueue
 
public:
    CommandQueue   : m_curr_cmd_it m_commands end      
    ~CommandQueue  
     
     
    CommandQueue const CommandQueue&     delete 
    CommandQueue& operator  const CommandQueue&     delete 

    CommandQueue CommandQueue&& rhs 
     
    	m_commands   std::move rhs m_commands  
    	m_curr_cmd_it   std::move rhs m_curr_cmd_it  
     

    CommandQueue& operator  CommandQueue&& rhs 
     
    	clear   
    	m_commands   std::move rhs m_commands  
    	m_curr_cmd_it   rhs m_curr_cmd_it 
    	return *this 
     

    int size   const   return m_commands size     

    void process Time time_diff  

    void push std::unique_ptr<Command> cmd 
     
		m_commands push_back std::move cmd   
     

    void insert_next std::unique_ptr<Command> cmd 
     
		m_commands insert std::next m_curr_cmd_it   std::move cmd   
     

    std::unique_ptr<Command> pop_next  
     
        auto it   std::next m_curr_cmd_it  
        std::unique_ptr<Command> cmd   std::move *it  
        m_commands erase it  
        return cmd 
     

    void clear  
     
        m_commands clear   
     

    void flush_commands  
     
        for auto it   m_commands begin    it    m_commands end      it 
        	if it    m_curr_cmd_it 
			 
				*it   std::make_unique<NullCommand>   
			 
     

private:
    std::list<std::unique_ptr<Command>> m_commands 
    std::list<std::unique_ptr<Command>>::iterator m_curr_cmd_it 
  

 * use_null_position_command h
 *



class UseNullPositionCommand : public Command
 
public:
	UseNullPositionCommand     

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseNullPositionCommand>     
  

 * add_character_command h
 *



class AddCharacterCommand : public Command
 
public:
    AddCharacterCommand double x  double y  double w  double h  double hp  SpritesheetID spr_id 
	: m_x x 
	  m_y y 
	  m_w w 
	  m_h h 
	  m_hp hp 
	  m_spr_id spr_id 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<AddCharacterCommand> m_x  m_y  m_w  m_h  m_hp  m_spr_id    

private:
    double m_x  m_y  m_w  m_h  m_hp 
    SpritesheetID m_spr_id 
  



 * clear_procedure_command h
 *



class ClearProcedureCommand : public Command
 
public:
    ClearProcedureCommand ProcedureID id  : m_id id    

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<ClearProcedureCommand> m_id    

private:
    ProcedureID m_id 
  


 * clear_all_procedures_command h
 *



class ClearAllProceduresCommand : public Command
 
public:
    ClearAllProceduresCommand     

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<ClearAllProceduresCommand>     
  

 * use_static_visuals_command h
 *



class UseStaticVisualsCommand : public Command
 
public:
	UseStaticVisualsCommand SpritesheetID spr_id  int sprite 
	: m_spr_id spr_id 
	  m_sprite sprite 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseStaticVisualsCommand> m_spr_id  m_sprite    
private:
    SpritesheetID m_spr_id 
    int m_sprite 
  

 * call_procedure_command h
 *



class CallProcedureCommand : public Command
 
public:
    CallProcedureCommand ProcedureID id 
    : m_id id 
      

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<CallProcedureCommand> m_id    

private:
    ProcedureID m_id 
  


 * modify_visuals_command h
 *



class ModifyVisualsCommand : public Command
 
public:
	ModifyVisualsCommand double render_state  double repeat_x  double repeat_y  double spr_id  double layer 
	: m_render_state render_state 
	  m_repeat_x repeat_x 
	  m_repeat_y repeat_y 
	  m_spr_id spr_id 
	  m_layer layer 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<ModifyVisualsCommand> m_render_state  m_repeat_x  m_repeat_y  m_spr_id  m_layer    
private:
	double m_render_state  m_repeat_x  m_repeat_y  m_spr_id  m_layer 
  


 * add_platform_command h
 *



class AddPlatformCommand : public Command
 
public:
    AddPlatformCommand double x  double y  double w  double h  SpritesheetID spr_id  double rx  double ry 
	: m_x x 
	  m_y y 
	  m_w w 
	  m_h h 
	  m_spr_id spr_id 
	  m_rx rx 
	  m_ry ry 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<AddPlatformCommand> m_x  m_y  m_w  m_h  m_spr_id  m_rx  m_ry    

private:
    double m_x  m_y  m_w  m_h 
    SpritesheetID m_spr_id 
    double m_rx  m_ry 
  


 * use_tiled_visuals_command h
 *



class UseTiledVisualsCommand : public Command
 
public:
	UseTiledVisualsCommand SpritesheetID spr_id  uint16_t repeat_x  uint16_t repeat_y 
	: m_spr_id spr_id 
	  m_repeat_x repeat_x 
	  m_repeat_y repeat_y 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseTiledVisualsCommand> m_spr_id  m_repeat_x  m_repeat_y    
private:
    SpritesheetID m_spr_id 
    uint16_t m_repeat_x  m_repeat_y 
  

 * use_menu_item_visuals_command h
 *



class UseMenuItemVisualsCommand : public Command
 
public:
	UseMenuItemVisualsCommand SpritesheetID spr_id 
	: m_spr_id spr_id 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseMenuItemVisualsCommand> m_spr_id    
private:
    SpritesheetID m_spr_id 
  


 * remove_entity_command h
 *



class RemoveEntityCommand : public Command
 
public:
    RemoveEntityCommand     

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<RemoveEntityCommand>     
  


 * modify_collision_command h
 *



class ModifyCollisionCommand : public Command
 
public:
	ModifyCollisionCommand double state  double standing_on  double on_collision_damage 
	: m_state state 
	  m_standing_on standing_on 
	  m_on_collision_damage on_collision_damage 
	  

	void execute   const 
	std::unique_ptr<Command> clone     return std::make_unique<ModifyCollisionCommand> m_state  m_standing_on  m_on_collision_damage    
private:
	double m_state  m_standing_on  m_on_collision_damage 
  

 * use_null_visuals_command h
 *



class UseNullVisualsCommand : public Command
 
public:
	UseNullVisualsCommand     

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseNullVisualsCommand>     
  

 * fix_view_width_command h
 *




class FixViewWidthCommand : public Command
 
public:
	FixViewWidthCommand     default 

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<FixViewWidthCommand>     

private:
  



 * execute_file_clean_command h
 *



class ExecuteFileCleanCommand : public Command
 
public:
    ExecuteFileCleanCommand const std::string& filename  SDL_Renderer* renderer 
    : m_filename filename 
	  m_renderer renderer 
      

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<ExecuteFileCleanCommand> m_filename  m_renderer    

private:
    std::string m_filename 
    SDL_Renderer* m_renderer 
  


 * use_null_interaction_command h
 *



class UseNullInteractionCommand : public Command
 
public:
	UseNullInteractionCommand     

    void execute   const 
	std::unique_ptr<Command> clone     return std::make_unique<UseNullInteractionCommand>     
  


 * use_null_health_command h
 *



class UseNullHealthCommand : public Command
 
public:
	UseNullHealthCommand     

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseNullHealthCommand>     
  


 * quit_command h
 *



class QuitCommand : public Command
 
public:
    QuitCommand     

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<QuitCommand>     
  


 * use_normal_interaction_command h
 *



class UseNormalInteractionCommand : public Command
 
public:
	UseNormalInteractionCommand int32_t group_vec 
	: m_group_vec group_vec 
	  

    void execute   const 
	std::unique_ptr<Command> clone     return std::make_unique<UseNormalInteractionCommand> m_group_vec    

private:
    int32_t m_group_vec 
  


 * pause_command h
 *



class PauseCommand : public Command
 
public:
    PauseCommand bool paused  : m_paused paused    

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<PauseCommand> m_paused    
private:
    bool m_paused 
  


 * add_projectile_command h
 *



class AddProjectileCommand : public Command
 
public:
    AddProjectileCommand double x  double y  double w  double h  SpritesheetID spr_id 
	: m_x x 
	  m_y y 
	  m_w w 
	  m_h h 
	  m_spr_id spr_id 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<AddProjectileCommand> m_x  m_y  m_w  m_h  m_spr_id    

private:
    double m_x  m_y  m_w  m_h 
    SpritesheetID m_spr_id 
  



 * modify_interaction_command h
 *



class ModifyInteractionCommand : public Command
 
public:
	ModifyInteractionCommand double group  double value  double trigger_group  double proc_id_self  double on_exit_proc_id_self  double proc_id_other 
	: m_group group 
	  m_value value 
	  m_trigger_group trigger_group 
	  m_proc_id_self proc_id_self 
	  m_on_exit_proc_id_self on_exit_proc_id_self 
	  m_proc_id_other proc_id_other 
	  

	void execute   const 
	std::unique_ptr<Command> clone     return std::make_unique<ModifyInteractionCommand> m_group  m_value  m_trigger_group  m_proc_id_self  m_on_exit_proc_id_self  m_proc_id_other    
private:
	double m_group  m_value  m_trigger_group  m_proc_id_self  m_on_exit_proc_id_self  m_proc_id_other 
  

 * modify_health_command h
 *



class ModifyHealthCommand : public Command
 
public:
	ModifyHealthCommand double max_hp  double hp  double hp_change 
	: m_max_hp max_hp 
	  m_hp hp 
	  m_hp_change hp_change 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<ModifyHealthCommand> m_max_hp  m_hp  m_hp_change    
private:
	double m_max_hp  m_hp  m_hp_change 
  


 * null_command h
 *



class NullCommand : public Command
 
public:
    void execute   const   
    std::unique_ptr<Command> clone     return std::make_unique<NullCommand>     
  

 * add_spritesheet_command h
 *



class AddSpritesheetCommand : public Command
 
public:
    AddSpritesheetCommand int idle_start  int idle_size
                          int walk_start  int walk_size
                          int jump_start  int jump_size
                          int fall_start  int fall_size
						  int attack_start  int attack_size
						  int hit_start  int hit_size
						  int dead_start  int dead_size
                          double scale_factor
                          : m_idle_start idle_start   m_idle_size idle_size 
                            m_walk_start walk_start   m_walk_size walk_size 
                            m_jump_start jump_start   m_jump_size jump_size 
                            m_fall_start fall_start   m_fall_size fall_size 
						    m_attack_start attack_start   m_attack_size attack_size 
						    m_hit_start hit_start   m_hit_size hit_size 
                            m_dead_start dead_start   m_dead_size dead_size 
                            m_scale_factor scale_factor 
                          

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<AddSpritesheetCommand> m_idle_start  m_idle_size
                                                            m_walk_start  m_walk_size
                                                            m_jump_start  m_jump_size
                                                            m_fall_start  m_fall_size
                                                            m_attack_start  m_attack_size
                                                            m_hit_start  m_hit_size
                                                            m_dead_start  m_dead_size
                                                            m_scale_factor
                                                              
                          

private:
    int m_idle_start  m_idle_size 
    int m_walk_start  m_walk_size 
    int m_jump_start  m_jump_size 
    int m_fall_start  m_fall_size 
    int m_attack_start  m_attack_size 
    int m_hit_start  m_hit_size 
    int m_dead_start  m_dead_size 
    double m_scale_factor 
  

 * extend_procedure_command h
 *



class ExtendProcedureCommand : public Command
 
public:
    ExtendProcedureCommand ProcedureID id  int num_of_commands 
    : m_id id 
      m_num_of_cmds num_of_commands 
      

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<ExtendProcedureCommand> m_id  m_num_of_cmds    

private:
    ProcedureID m_id 
    int m_num_of_cmds 
  

 * use_absolute_position_command h
 *



class UseAbsolutePositionCommand : public Command
 
public:
    UseAbsolutePositionCommand const AbsolutePosition& position 
	: m_position position    

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseAbsolutePositionCommand> m_position    
private:
    AbsolutePosition m_position 
  


 * use_null_control_command h
 *



class UseNullControlCommand : public Command
 
public:
	UseNullControlCommand     

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseNullControlCommand>     
  

 * use_full_interaction_command h
 *



class UseFullInteractionCommand : public Command
 
public:
	UseFullInteractionCommand int32_t group_vec  int8_t trigger_group  ProcedureID on_enter_proc_id_self  ProcedureID on_exit_proc_id_self  ProcedureID on_enter_proc_id_other 
	: m_group_vec group_vec 
	  m_trigger_group trigger_group 
	  m_on_enter_proc_id_self on_enter_proc_id_self 
	  m_on_exit_proc_id_self on_exit_proc_id_self 
	  m_on_enter_proc_id_other on_enter_proc_id_other 
	  

    void execute   const 
	std::unique_ptr<Command> clone     return std::make_unique<UseFullInteractionCommand> m_group_vec  m_trigger_group  m_on_enter_proc_id_self  m_on_exit_proc_id_self  m_on_enter_proc_id_other    

private:
    int32_t m_group_vec 
    int8_t m_trigger_group 
    ProcedureID m_on_enter_proc_id_self  m_on_exit_proc_id_self  m_on_enter_proc_id_other 
  

 * add_visual_object_command h
 *



class AddVisualObjectCommand : public Command
 
public:
    AddVisualObjectCommand double x  double y  double w  double h  SpritesheetID spr_id  int sprite 
	: m_x x 
	  m_y y 
	  m_w w 
	  m_h h 
	  m_spr_id spr_id 
	  m_sprite sprite 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<AddVisualObjectCommand> m_x  m_y  m_w  m_h  m_spr_id  m_sprite    

private:
    double m_x  m_y  m_w  m_h 
    SpritesheetID m_spr_id 
    int m_sprite 
  



 * use_full_movement_command h
 *



class UseFullMovementCommand : public Command
 
public:
	UseFullMovementCommand double mass  double friction  double move_force  double jump_force  bool gravity_affected 
	: m_mass mass 
	  m_friction friction 
	  m_move_force move_force 
	  m_jump_force jump_force 
	  m_gravity_affected gravity_affected 
	  

	void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseFullMovementCommand> m_mass  m_friction  m_move_force  m_jump_force  m_gravity_affected    

private:
    double m_mass  m_friction  m_move_force  m_jump_force 
	bool m_gravity_affected 
  


 * use_null_movement_command h
 *



class UseNullMovementCommand : public Command
 
public:
	UseNullMovementCommand     

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseNullMovementCommand>     
  


 * use_attached_position_command h
 *



class UseAttachedPositionCommand : public Command
 
public:
	UseAttachedPositionCommand EntityID id  double offset_x  double offset_y  double offset_w  double offset_h 
	: m_id id 
	  m_offset_x offset_x 
	  m_offset_y offset_y 
	  m_offset_w offset_w 
	  m_offset_h offset_h 
	  

    void execute   const 
	std::unique_ptr<Command> clone     return std::make_unique<UseAttachedPositionCommand> m_id  m_offset_x  m_offset_y  m_offset_w  m_offset_h    
private:
    EntityID m_id 
    double m_offset_x  m_offset_y  m_offset_w  m_offset_h 
  

 * add_entity_command h
 *



class AddEntityCommand : public Command
 
public:
    AddEntityCommand     
    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<AddEntityCommand>     
  


 * use_health_visuals_command h
 *



class UseHealthVisualsCommand : public Command
 
public:
	UseHealthVisualsCommand SpritesheetID spr_id  uint16_t repeat_x 
	: m_spr_id spr_id 
	  m_repeat_x repeat_x 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseHealthVisualsCommand> m_spr_id  m_repeat_x    
private:
    SpritesheetID m_spr_id 
    uint16_t m_repeat_x 
  


 * use_trigger_interaction_command h
 *



class UseTriggerInteractionCommand : public Command
 
public:
	UseTriggerInteractionCommand int8_t trigger_group  ProcedureID on_enter_proc_id_self  ProcedureID on_enter_proc_id_other  ProcedureID on_exit_proc_id_self 
	: m_trigger_group trigger_group 
	  m_on_enter_proc_id_self on_enter_proc_id_self 
	  m_on_enter_proc_id_other on_enter_proc_id_other 
	  m_on_exit_proc_id_self on_exit_proc_id_self 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseTriggerInteractionCommand> m_trigger_group  m_on_enter_proc_id_self  m_on_enter_proc_id_other  m_on_exit_proc_id_self    

private:
    int8_t m_trigger_group 
    ProcedureID m_on_enter_proc_id_self  m_on_enter_proc_id_other  m_on_exit_proc_id_self 
  

 * add_font_command h
 *



class AddFontCommand : public Command
 
public:
	AddFontCommand const std::string& file  int size 
	: m_file file 
	  m_size size 
	  
    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<AddFontCommand> m_file  m_size    

private:
    std::string m_file 
    int m_size 
  


 * use_input_select_control_command h
 *



class UseInputSelectControlCommand : public Command
 
public:
	UseInputSelectControlCommand int select  int max  ProcedureID proc_id 
	: m_select select 
	  m_max max 
	  m_proc_id proc_id 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseInputSelectControlCommand> m_select  m_max  m_proc_id    
private:
    int m_select 
    int m_max 
    ProcedureID m_proc_id 
  


 * add_texture_from_file_command h
 *



class AddTextureFromFileCommand : public Command
 
public:
    AddTextureFromFileCommand const std::string& file  SDL_Renderer* renderer  : m_file file   m_renderer renderer    
    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<AddTextureFromFileCommand> m_file  m_renderer    

private:
    std::string m_file 
    SDL_Renderer* m_renderer 
  


 * use_guide_control_command h
 *



class UseGuideControlCommand : public Command
 
public:
	UseGuideControlCommand EntityID target_id  ProcedureID attack_proc_id  double attack_cooldown  double attack_range 
	: m_target_id target_id 
	  m_attack_proc_id attack_proc_id 
	  m_attack_cooldown attack_cooldown 
	  m_range attack_range 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseGuideControlCommand> m_target_id  m_attack_proc_id  m_attack_cooldown  m_range    
private:
    EntityID m_target_id 
    ProcedureID m_attack_proc_id 
    double m_attack_cooldown 
    double m_range 
  

 * clear_all_entities_command h
 *



class ClearAllEntitiesCommand : public Command
 
public:
	ClearAllEntitiesCommand     

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<ClearAllEntitiesCommand>     
  


 * set_level_command h
 *



class SetLevelCommand : public Command
 
public:
	SetLevelCommand const std::string& level 
	: m_level level 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<SetLevelCommand> m_level    

private:
    std::string m_level 
  




 * use_basic_collision_command h
 *



class UseBasicCollisionCommand : public Command
 
public:
	UseBasicCollisionCommand Collision::CollisionState state 
	: m_state state 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseBasicCollisionCommand> m_state    
private:
    Collision::CollisionState m_state 
  


 * modify_position_command h
 *



class ModifyPositionCommand : public Command
 
public:
	ModifyPositionCommand double x  double y  double w  double h 
	: m_x x 
	  m_y y 
	  m_w w 
	  m_h h 
	  

	void execute   const 
	std::unique_ptr<Command> clone     return std::make_unique<ModifyPositionCommand> m_x  m_y  m_w  m_h    
private:
    double m_x  m_y  m_w  m_h 
  


 * use_instant_movement_command h
 *



class UseInstantMovementCommand : public Command
 
public:
	UseInstantMovementCommand double mass  double friction  double move_force 
	: m_mass mass 
	  m_friction friction 
	  m_move_force move_force 
	  

    void execute   const 
	std::unique_ptr<Command> clone     return std::make_unique<UseInstantMovementCommand> m_mass  m_friction  m_move_force    

private:
    double m_mass  m_friction  m_move_force 
  

 * use_constant_control_command h
 *



class UseConstantControlCommand : public Command
 
public:
	UseConstantControlCommand int8_t move_dec  bool jump_dec  bool duck_dec  Control::LookDir look_dir 
	: m_move_decision move_dec 
	  m_jump_decision jump_dec 
	  m_duck_decision duck_dec 
	  m_look_dir look_dir 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseConstantControlCommand> m_move_decision  m_jump_decision  m_duck_decision  m_look_dir    
private:
	int8_t m_move_decision 
	bool m_jump_decision 
	bool m_duck_decision 
	Control::LookDir m_look_dir 
  


 * clear_all_textures_command h
 *



class ClearAllTexturesCommand : public Command
 
public:
	ClearAllTexturesCommand     

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<ClearAllTexturesCommand>     
  


 * use_null_collision_command h
 *



class UseNullCollisionCommand : public Command
 
public:
	UseNullCollisionCommand     

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseNullCollisionCommand>     
  

 * use_input_control_command h
 *



class UseInputControlCommand : public Command
 
public:
	UseInputControlCommand ProcedureID shoot_id  double shoot_cooldown 
	: m_shoot_id shoot_id 
	  m_shoot_cooldown shoot_cooldown 
	  

	void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseInputControlCommand> m_shoot_id  m_shoot_cooldown    
private:
    ProcedureID m_shoot_id 
    double m_shoot_cooldown 
  

 * execute_file_command h
 *



class ExecuteFileCommand : public Command
 
public:
    ExecuteFileCommand const std::string& filename  SDL_Renderer* renderer 
    : m_filename filename 
	  m_renderer renderer 
      

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<ExecuteFileCommand> m_filename  m_renderer    

private:
    std::string m_filename 
    SDL_Renderer* m_renderer 
  


 * add_sprite_command h
 *



class AddSpriteCommand : public Command
 
public:
    AddSpriteCommand SpritesheetID spr_id  TextureID tex_id  int x  int y  int w  int h 
    : m_spr_id spr_id 
      m_tex_id tex_id 
      m_x x 
      m_y y 
      m_w w 
      m_h h 
      
    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<AddSpriteCommand> m_spr_id  m_tex_id  m_x  m_y  m_w  m_h    

private:
    SpritesheetID m_spr_id 
    TextureID m_tex_id 
    int m_x  m_y  m_w  m_h 
  


 * use_damage_collision_command h
 *



class UseDamageCollisionCommand : public Command
 
public:
	UseDamageCollisionCommand Collision::CollisionState state  double damage 
	: m_state state 
	  m_damage damage 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseDamageCollisionCommand> m_state  m_damage    
private:
    Collision::CollisionState m_state 
    double m_damage 
  



 * clear_all_spritesheets_command h
 *



class ClearAllSpritesheetsCommand : public Command
 
public:
	ClearAllSpritesheetsCommand     

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<ClearAllSpritesheetsCommand>     
  

 * add_procedure_command h
 *



class AddProcedureCommand : public Command
 
public:
    AddProcedureCommand int num_of_cmds  : m_num_of_cmds num_of_cmds    

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<AddProcedureCommand> m_num_of_cmds    
private:
    int m_num_of_cmds 
  


 * debug_message_command h
 *



class DebugMessageCommand : public Command
 
public:
	enum Severity  DEBUG   0  NOTE   1  ERROR   2  
    DebugMessageCommand const std::string& debug_text  Severity sev 
	: m_text debug_text 
	  m_severity sev 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<DebugMessageCommand> m_text  m_severity    

private:
    std::string m_text 
    Severity m_severity 
  


 * use_timed_health_command h
 *



class UseTimedHealthCommand : public Command
 
public:
	UseTimedHealthCommand double ttl  ProcedureID proc_id 
	: m_ttl ttl 
	  m_proc_id proc_id 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseTimedHealthCommand> m_ttl  m_proc_id    
private:
    double m_ttl 
    ProcedureID m_proc_id 
  

 * modify_control_command h
 *



class ModifyControlCommand : public Command
 
public:
	ModifyControlCommand double decision_jump  double decision_duck  double decision_attack  double decision_walk  double look_dir 
	: m_decision_jump decision_jump 
	  m_decision_duck decision_duck 
	  m_decision_attack decision_attack 
	  m_decision_walk decision_walk 
	  m_look_dir look_dir 
	  

	void execute   const 
	std::unique_ptr<Command> clone     return std::make_unique<ModifyControlCommand> m_decision_jump  m_decision_duck  m_decision_attack  m_decision_walk  m_look_dir    
private:
    double m_decision_jump 
    double m_decision_duck 
    double m_decision_attack 
    double m_decision_walk 
    double m_look_dir 
  


 * use_chase_ai_control_command h
 *



class UseChaseAIControlCommand : public Command
 
public:
	UseChaseAIControlCommand EntityID target_id  ProcedureID attack_id  double attack_cooldown  double attack_range 
	: m_target_id target_id 
	  m_attack_id attack_id 
	  m_attack_cooldown attack_cooldown 
	  m_attack_range attack_range 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseChaseAIControlCommand> m_target_id  m_attack_id  m_attack_cooldown  m_attack_range    

private:
    EntityID m_target_id 
    ProcedureID m_attack_id 
    double m_attack_cooldown  m_attack_range 
  



 * procedure_command h
 *



class ProcedureCommand : public Command
 
public:
    void add_command std::unique_ptr<Command> cmd 
     
        m_commands push_back std::move cmd   
     

    void clear  
     
        m_commands clear   
     

    void execute   const 
    std::unique_ptr<Command> clone  
     
        ProcedureCommand cmd   ProcedureCommand   
        for auto it   m_commands begin    it    m_commands end      it 
            cmd add_command  *it  clone    
        return std::make_unique<ProcedureCommand> std::move cmd   
     

private:
    std::list<std::unique_ptr<Command>> m_commands 
  



 * use_attached_health_command h
 *



class UseAttachedHealthCommand : public Command
 
public:
	UseAttachedHealthCommand EntityID attached_id  double offset_hp  double offset_max_hp 
	: m_attached_id attached_id 
	  m_offset_hp offset_hp 
	  m_offset_max_hp offset_max_hp 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseAttachedHealthCommand> m_attached_id  m_offset_hp  m_offset_max_hp    
private:
    EntityID m_attached_id 
    double m_offset_hp  m_offset_max_hp 
  


 * use_character_health_command h
 *



class UseCharacterHealthCommand : public Command
 
public:
	UseCharacterHealthCommand double hp  double max_hp 
	: m_hp hp 
	  m_max_hp max_hp 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseCharacterHealthCommand> m_hp  m_max_hp    
private:
    double m_hp  m_max_hp 
  


 * use_character_visuals_command h
 *



class UseCharacterVisualsCommand : public Command
 
public:
	UseCharacterVisualsCommand SpritesheetID spr_id 
	: m_spr_id spr_id 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<UseCharacterVisualsCommand> m_spr_id    
private:
    SpritesheetID m_spr_id 
  

 * select_entity_command h
 *



class SelectEntityCommand : public Command
 
public:
	SelectEntityCommand EntityID id 
	: m_id id 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<SelectEntityCommand> m_id    

private:
    EntityID m_id 
  

 * modify_movement_command h
 *



class ModifyMovementCommand : public Command
 
public:
	ModifyMovementCommand double mass  double friction  double vx  double vy  double fx  double fy  double gravity_affected 
	: m_mass mass 
	  m_friction friction 
	  m_vx vx 
	  m_vy vy 
	  m_fx fx 
	  m_fy fy 
	  m_gravity_affected gravity_affected 
	  

	void execute   const 
	std::unique_ptr<Command> clone     return std::make_unique<ModifyMovementCommand> m_mass  m_friction  m_vx  m_vy  m_fx  m_fy  m_gravity_affected    
private:
    double m_mass  m_friction  m_vx  m_vy  m_fx  m_fy  m_gravity_affected 
  


 * add_zone_command h
 *



class AddZoneCommand : public Command
 
public:
    AddZoneCommand double x  double y  double w  double h  int8_t trigger_group  ProcedureID on_enter_proc_id_self  ProcedureID on_exit_proc_id_self  ProcedureID on_enter_proc_id_other 
	: m_x x 
	  m_y y 
	  m_w w 
	  m_h h 
	  m_trigger_group trigger_group 
	  m_on_enter_proc_id_self on_enter_proc_id_self 
	  m_on_exit_proc_id_self on_exit_proc_id_self 
	  m_on_enter_proc_id_other on_enter_proc_id_other 
	  

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<AddZoneCommand> m_x  m_y  m_w  m_h  m_trigger_group  m_on_enter_proc_id_self  m_on_exit_proc_id_self  m_on_enter_proc_id_other    

private:
    double m_x  m_y  m_w  m_h 
    int8_t m_trigger_group 
    ProcedureID m_on_enter_proc_id_self  m_on_exit_proc_id_self  m_on_enter_proc_id_other 
  


 * add_texture_from_string_command h
 *



class AddTextureFromStringCommand : public Command
 
public:
    AddTextureFromStringCommand const std::string& text  FontID font_id  uint8_t r  uint8_t g  uint8_t b  SDL_Renderer* renderer 
	: m_text text 
	  m_font_id font_id 
	  m_r r 
	  m_g g 
	  m_b b 
	  m_renderer renderer    

    void execute   const 
    std::unique_ptr<Command> clone     return std::make_unique<AddTextureFromStringCommand> m_text  m_font_id  m_r  m_g  m_b  m_renderer    

private:
    std::string m_text 
    FontID m_font_id 
    uint8_t m_r  m_g  m_b 
    SDL_Renderer* m_renderer 
  


 * command h
 *



class Command
 
public:
    virtual ~Command     
    virtual void execute   const   0 
    virtual std::unique_ptr<Command> clone     0 
  

